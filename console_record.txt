load "C:/Users/Administrator/Desktop/AUTOMATION/cutlist/AutoNestCut/dev_toolbar.rb"
=> true
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [07:35:34]
✅ AutoNestCut icon loaded: C:/Users/Administrator/Desktop/AUTOMATION/cutlist/AutoNestCut/AutoNestCut_Clean_Workspace/Extension/AutoNestCut/resources/icon.png
DEBUG: Generated 5 boards successfully
DEBUG: ReportGenerator.generate_report_data called with 5 boards
DEBUG: Report settings - currency: SAR, units: mm, precision: 0
DEBUG: Generated report data:
  - Parts placed: 17
  - Unique part types: 17
  - Boards: 5
  - Total project cost: 1700
DEBUG: Sending report data to frontend:
  - Diagrams count: 5
  - Report summary: {:total_parts_instances=>17, :total_unique_part_types=>17, :total_boards=>5, :total_stock_area=>4800000, :total_used_area=>3168900, :total_waste_area=>1631100, :overall_waste_percentage=>33.98, :overall_efficiency=>66.02000000000001, :total_project_cost=>1700, :currency=>"SAR", :units=>"mm", :precision=>0}
  - Parts placed count: 17
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [07:49:23]
DEBUG: Generated 5 boards successfully
DEBUG: ReportGenerator.generate_report_data called with 5 boards
DEBUG: Report settings - currency: SAR, units: mm, precision: 0
DEBUG: Generated report data:
  - Parts placed: 17
  - Unique part types: 17
  - Boards: 5
  - Total project cost: 1700
DEBUG: Sending report data to frontend:
  - Diagrams count: 5
  - Report summary: {:total_parts_instances=>17, :total_unique_part_types=>17, :total_boards=>5, :total_stock_area=>4800000, :total_used_area=>3168900, :total_waste_area=>1631100, :overall_waste_percentage=>33.98, :overall_efficiency=>66.02000000000001, :total_project_cost=>1700, :currency=>"SAR", :units=>"mm", :precision=>0}
  - Parts placed count: 17
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [07:59:36]
DEBUG: Generated 5 boards successfully
DEBUG: ReportGenerator.generate_report_data called with 5 boards
DEBUG: Report settings - currency: SAR, units: mm, precision: 0
DEBUG: Generated report data:
  - Parts placed: 17
  - Unique part types: 17
  - Boards: 5
  - Total project cost: 1700
DEBUG: Sending report data to frontend:
  - Diagrams count: 5
  - Report summary: {:total_parts_instances=>17, :total_unique_part_types=>17, :total_boards=>5, :total_stock_area=>4800000, :total_used_area=>3168900, :total_waste_area=>1631100, :overall_waste_percentage=>33.98, :overall_efficiency=>66.02000000000001, :total_project_cost=>1700, :currency=>"SAR", :units=>"mm", :precision=>0}
  - Parts placed count: 17
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [08:21:55]
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [08:21:58]
DEBUG: Generated 5 boards successfully
DEBUG: ReportGenerator.generate_report_data called with 5 boards
DEBUG: Report settings - currency: SAR, units: mm, precision: 0
DEBUG: Generated report data:
  - Parts placed: 17
  - Unique part types: 17
  - Boards: 5
  - Total project cost: 1700
DEBUG: Sending report data to frontend:
  - Diagrams count: 5
  - Report summary: {:total_parts_instances=>17, :total_unique_part_types=>17, :total_boards=>5, :total_stock_area=>4800000, :total_used_area=>3168900, :total_waste_area=>1631100, :overall_waste_percentage=>33.98, :overall_efficiency=>66.02000000000001, :total_project_cost=>1700, :currency=>"SAR", :units=>"mm", :precision=>0}
  - Parts placed count: 17
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [10:03:14]
DEBUG: Generated 5 boards successfully
DEBUG: ReportGenerator.generate_report_data called with 5 boards
DEBUG: Report settings - currency: SAR, units: mm, precision: 0
DEBUG: Generated report data:
  - Parts placed: 17
  - Unique part types: 17
  - Boards: 5
  - Total project cost: 1700
DEBUG: Sending report data to frontend:
  - Diagrams count: 5
  - Report summary: {:total_parts_instances=>17, :total_unique_part_types=>17, :total_boards=>5, :total_stock_area=>4800000, :total_used_area=>3168900, :total_waste_area=>1631100, :overall_waste_percentage=>33.98, :overall_efficiency=>66.02000000000001, :total_project_cost=>1700, :currency=>"SAR", :units=>"mm", :precision=>0}
  - Parts placed count: 17
module SpiralStairsGenerator
  # --- Standard Dimensions (in millimeters) ---
  TOTAL_HEIGHT = 3000.mm         # Overall vertical height of the staircase
  NUM_STEPS = 16                 # Total number of individual steps (excluding ground, including top landing step)
  STEPS_PER_REVOLUTION = 12      # How many steps make a full 360-degree turn
  NEWEL_RADIUS = 100.mm          # Radius of the central support pole
  OUTER_TREAD_RADIUS = 1000.mm   # Overall radius of the staircase (to the outer edge of the steps)
  TREAD_THICKNESS = 50.mm        # Vertical thickness of the tread itself

  # --- Handrail Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread top surface to handrail top surface
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_OUTER_EDGE = 50.mm # Horizontal offset from the outer edge of the tread (inward)

  # --- Derived Parameters ---
  RISER_HEIGHT = TOTAL_HEIGHT / NUM_STEPS # Vertical height of each step
  ANGLE_PER_STEP = 360.degrees / STEPS_PER_REVOLUTION # Angular sweep for one step

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      case color_name
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey for newel
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white for treads
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown for handrail
      end
    end
    group.material = material
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # 1. Create the path edges
    path_edges = group_entities.add_curve(path_points)
    unless path_edges && path_edges.length > 0 # A path needs at least one edge (two points)
      puts "Error: Invalid path for handrail #{name}. Not enough points: #{path_points.length} points."
      handrail_group.erase!
      return nil
    end

    # 2. Define the profile face's vertices.
    # The path_points define the center line of the handrail.
    # The profile face needs to be perpendicular to the first segment of the path.

    # Ensure there are at least two points to form a vector.
    if path_points.length < 2
      puts "Error: Handrail path for #{name} has less than 2 points."
      handrail_group.erase!
      return nil
    end
    
    # Get the vector of the first segment of the path.
    v_path = (path_points[1] - path_points[0]).normalize
    
    # Calculate the radial vector for the first point's XY projection
    radial_vec = Geom::Vector3d.new(path_points.first.x, path_points.first.y, 0)
    
    # Check if radial_vec is zero (i.e., path starts at (0,0,Z))
    if radial_vec.length < 0.001.mm # Use a small tolerance
      # If at origin, local_xaxis can be X_AXIS (or any horizontal axis)
      local_xaxis = X_AXIS
    else
      # local_xaxis is tangential to the circle at path_points.first.x,y
      # This is radial_vec crossed with Z_AXIS (for a counter-clockwise spiral from X-axis).
      local_xaxis = radial_vec.cross(Z_AXIS).normalize
    end
    
    # local_zaxis should be perpendicular to both v_path and local_xaxis.
    local_zaxis = v_path.cross(local_xaxis).normalize 
    
    # Ensure local_zaxis points generally upwards.
    if local_zaxis.z < 0
      local_zaxis.reverse!
      # Re-calculate local_xaxis if local_zaxis was reversed to maintain orthogonality.
      local_xaxis = v_path.cross(local_zaxis).normalize 
    end
    
    # Transformation to align the profile. `axes(origin, x_axis, y_axis, z_axis)`
    # The `y_axis` here is the extrusion direction (`v_path`).
    tr_profile_alignment = Geom::Transformation.axes(path_points.first, local_xaxis, v_path, local_zaxis)

    # Define the profile points relative to its own local origin (0,0,0) and axes.
    # The profile will be centered on path_points.first, and lie in the local XZ plane.
    local_pts = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-left
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-right
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2), # Top-right
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)  # Top-left
    ]
    
    # Transform these local points to their absolute positions in the model space.
    absolute_pts = local_pts.map { |pt| pt.transform(tr_profile_alignment) }

    # Create the profile face in the group's entities
    profile_face = group_entities.add_face(absolute_pts)

    if profile_face.valid?
      # Ensure the face normal points *away* from the path's direction for FollowMe to work reliably.
      # If `profile_face.normal.dot(v_path)` is positive, the face is pointing along the path, so reverse it.
      if profile_face.normal.dot(v_path) > 0.001 # Use a small tolerance for comparison
        profile_face.reverse!
      end
      
      # Now use followme
      profile_face.followme(path_edges)
      return handrail_group
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile face creation failed or is invalid."
      handrail_group.erase!
      return nil
    end
  end


  def self.generate_spiral_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate Spiral Stairs", true)

    # --- Main Group for the entire staircase ---
    spiral_stairs_assembly = create_solid_group(entities, "Spiral_Stairs_Assembly")
    assembly_entities = spiral_stairs_assembly.entities

    # --- 1. Central Newel ---
    newel_group = create_solid_group(assembly_entities, "Newel_Post")
    apply_color(newel_group, "Grey")
    newel_entities = newel_group.entities

    # Create the base circle for the newel post at Z=0
    center_point = Geom::Point3d.new(0, 0, 0)
    normal = Geom::Vector3d.new(0, 0, 1) # XY plane
    newel_circle = newel_entities.add_circle(center_point, normal, NEWEL_RADIUS)
    newel_face = newel_entities.add_face(newel_circle)
    
    # Push-pull the newel to the total height (plus tread thickness for visual coherence)
    newel_face.pushpull(TOTAL_HEIGHT + TREAD_THICKNESS) if newel_face.valid?

    # --- 2. Treads ---
    treads_group = create_solid_group(assembly_entities, "Treads_Assembly")
    apply_color(treads_group, "White") # Default color for treads

    # Starting angle for the first step (e.g., along the X-axis for consistency)
    start_angle_offset = 0.degrees 

    (0...NUM_STEPS).each do |i|
      step_group = create_solid_group(treads_group.entities, "Step_#{i+1}")
      step_entities = step_group.entities

      current_base_z = i * RISER_HEIGHT # Z-coordinate for the bottom of the current tread
      current_start_angle = start_angle_offset + (i * ANGLE_PER_STEP)
      current_end_angle = current_start_angle + ANGLE_PER_STEP

      # Define points for the wedge-shaped tread at its base (Z = current_base_z)
      # Inner-front point (closest to newel, at current_start_angle)
      pt1 = Geom::Point3d.new(NEWEL_RADIUS * Math.cos(current_start_angle), 
                              NEWEL_RADIUS * Math.sin(current_start_angle), 
                              current_base_z)
      # Outer-front point
      pt2 = Geom::Point3d.new(OUTER_TREAD_RADIUS * Math.cos(current_start_angle), 
                              OUTER_TREAD_RADIUS * Math.sin(current_start_angle), 
                              current_base_z)
      # Outer-back point
      pt3 = Geom::Point3d.new(OUTER_TREAD_RADIUS * Math.cos(current_end_angle), 
                              OUTER_TREAD_RADIUS * Math.sin(current_end_angle), 
                              current_base_z)
      # Inner-back point
      pt4 = Geom::Point3d.new(NEWEL_RADIUS * Math.cos(current_end_angle), 
                              NEWEL_RADIUS * Math.sin(current_end_angle), 
                              current_base_z)

      face = step_entities.add_face([pt1, pt2, pt3, pt4])
      face.pushpull(TREAD_THICKNESS) if face.valid?
    end

    # --- 3. Handrail ---
    handrail_group = create_solid_group(assembly_entities, "Handrail")
    apply_color(handrail_group, "Wood")
    
    # Calculate the radius for the handrail's centerline.
    handrail_centerline_radius = OUTER_TREAD_RADIUS - HANDRAIL_OFFSET_FROM_OUTER_EDGE - (HANDRAIL_WIDTH / 2)

    handrail_path_points = []
    
    # Generate points for each step level, including the 'ground' level (i=0) and the 'top landing' level (i=NUM_STEPS)
    # This loop covers NUM_STEPS + 1 points, each distinct in angle and Z.
    (0..NUM_STEPS).each do |i| 
      current_angle = start_angle_offset + (i * ANGLE_PER_STEP)
      current_z = (i * RISER_HEIGHT) + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)

      x = handrail_centerline_radius * Math.cos(current_angle)
      y = handrail_centerline_radius * Math.sin(current_angle)
      handrail_path_points << Geom::Point3d.new(x, y, current_z)
    end
    
    # Create the handrail geometry
    create_handrail(assembly_entities, handrail_path_points, "Spiral_Handrail")

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(spiral_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
SpiralStairsGenerator.generate_spiral_stairs

=> #<Sketchup::View:0x000000001dac01d0>
module SpiralStairsGenerator
  # --- Standard Dimensions (in millimeters) ---
  TOTAL_HEIGHT = 3000.mm         # Overall vertical height of the staircase
  NUM_STEPS = 16                 # Total number of individual steps (excluding ground, including top landing step)
  STEPS_PER_REVOLUTION = 12      # How many steps make a full 360-degree turn
  NEWEL_RADIUS = 100.mm          # Radius of the central support pole
  OUTER_TREAD_RADIUS = 1000.mm   # Overall radius of the staircase (to the outer edge of the steps)
  TREAD_THICKNESS = 50.mm        # Vertical thickness of the tread itself

  # --- Handrail Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread top surface to handrail top surface
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_OUTER_EDGE = 50.mm # Horizontal offset from the outer edge of the tread (inward)

  # --- Derived Parameters ---
  RISER_HEIGHT = TOTAL_HEIGHT / NUM_STEPS # Vertical height of each step
  ANGLE_PER_STEP = 360.degrees / STEPS_PER_REVOLUTION # Angular sweep for one step

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      case color_name
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey for newel
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white for treads
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown for handrail
      end
    end
    group.material = material
  end

  # Helper to create a handrail using FollowMe
  # This helper is adapted from the U-Stairs script to work with a helical path.
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # 1. Create the path edges
    path_edges = group_entities.add_curve(path_points)
    unless path_edges && path_edges.length > 0 # A path needs at least one edge (two points)
      puts "Error: Invalid path for handrail #{name}. Not enough points: #{path_points.length} points."
      handrail_group.erase!
      return nil
    end

    # 2. Define the profile face's vertices.
    # The path_points define the center line of the handrail.
    # The profile face needs to be perpendicular to the first segment of the path.

    # Get the vector of the first segment of the path.
    # Handle the case where the path is purely vertical (unlikely for spiral, but good to check).
    if path_points.length < 2
      puts "Error: Handrail path for #{name} has less than 2 points."
      handrail_group.erase!
      return nil
    end
    v_path = (path_points[1] - path_points[0]).normalize
    
    # Create a transformation to align the profile at the start of the path.
    # v_path will be the local Y-axis (extrusion direction for FollowMe).
    # We need local X and Z axes perpendicular to v_path.
    # `v_path.axes` returns an array: [v_path, perpendicular_x, perpendicular_z] (arbitrary order for latter two).
    # We want local X to be primarily horizontal (radial) and local Z to be vertical.
    
    # Calculate horizontal tangent (local X for profile)
    # The path's horizontal projection is a circle. The tangent to this circle is perpendicular to the radius vector.
    # Radius vector at path_points.first: `path_points.first.vector_to(Geom::Point3d.new(0,0,path_points.first.z))`
    # From origin: `vector_from_origin = Geom::Vector3d.new(path_points.first.x, path_points.first.y, 0)`
    # Horizontal tangent vector is `vector_from_origin.cross(Z_AXIS).normalize` or `Z_AXIS.cross(vector_from_origin).normalize`
    
    # Let's simplify and use SketchUp's `axes` method, then ensure profile's 'up' is close to Z_AXIS.
    # local_xaxis will be perpendicular to v_path.
    # local_yaxis is v_path (along the path).
    # local_zaxis is perpendicular to both, ideally pointing "up".
    
    # Try to make the profile's 'up' direction (local Z) as close to global Z as possible,
    # and local X (width) mostly radial.
    
    # The `axes` method might return an arbitrary orientation. We need to ensure
    # the profile is oriented correctly (e.g., handrail top is horizontal).
    
    # A robust way:
    # 1. Path tangent `v_path`.
    # 2. Vector from origin to current point (horizontal part): `radial_vec = Geom::Vector3d.new(path_points.first.x, path_points.first.y, 0).normalize`
    # 3. Horizontal axis for profile (transverse to path and radial): `local_xaxis = radial_vec.cross(Z_AXIS).normalize`
    #    This ensures `local_xaxis` is tangential to the circle at `path_points.first.x,y`.
    # 4. Vertical axis for profile: `local_zaxis = v_path.cross(local_xaxis).normalize`
    #    This ensures `local_zaxis` is perpendicular to both path and horizontal axis.

    radial_vec = Geom::Vector3d.new(path_points.first.x, path_points.first.y, 0).normalize
    local_xaxis = radial_vec.cross(Z_AXIS).normalize # This is the horizontal vector tangential to the circle (width direction)
    local_zaxis = v_path.cross(local_xaxis).normalize # This is the vertical vector (depth direction of profile)
    
    # Ensure local_zaxis points generally upwards.
    if local_zaxis.z < 0
      local_zaxis.reverse!
      local_xaxis = v_path.cross(local_zaxis).normalize # Re-calculate local_xaxis if local_zaxis reversed.
    end
    
    # Transformation to align the profile. `axes(origin, x_axis, y_axis, z_axis)`
    tr_profile_alignment = Geom::Transformation.axes(path_points.first, local_xaxis, v_path, local_zaxis)

    # Define the profile points relative to its own local origin (0,0,0) and axes.
    # The profile will be centered on path_points.first, and lie in the local XZ plane.
    # (Local X is handrail width, Local Z is handrail depth)
    local_pts = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-left
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-right
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2), # Top-right
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)  # Top-left
    ]
    
    # Transform these local points to their absolute positions in the model space.
    absolute_pts = local_pts.map { |pt| pt.transform(tr_profile_alignment) }

    # Create the profile face in the group's entities
    profile_face = group_entities.add_face(absolute_pts)

    if profile_face.valid?
      # Ensure the face normal points *away* from the path's direction for FollowMe to work reliably.
      # If `profile_face.normal.dot(v_path)` is positive, the face is pointing along the path, so reverse it.
      if profile_face.normal.dot(v_path) > 0.001 # Use a small tolerance for comparison
        profile_face.reverse!
      end
      
      # Now use followme
      profile_face.followme(path_edges)
      return handrail_group
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile face creation failed or is invalid."
      handrail_group.erase!
      return nil
    end
  end


  def self.generate_spiral_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate Spiral Stairs", true)

    # --- Main Group for the entire staircase ---
    spiral_stairs_assembly = create_solid_group(entities, "Spiral_Stairs_Assembly")
    assembly_entities = spiral_stairs_assembly.entities

    # --- 1. Central Newel ---
    newel_group = create_solid_group(assembly_entities, "Newel_Post")
    apply_color(newel_group, "Grey")
    newel_entities = newel_group.entities

    # Create the base circle for the newel post at Z=0
    center_point = Geom::Point3d.new(0, 0, 0)
    normal = Geom::Vector3d.new(0, 0, 1) # XY plane
    newel_circle = newel_entities.add_circle(center_point, normal, NEWEL_RADIUS)
    newel_face = newel_entities.add_face(newel_circle)
    
    # Push-pull the newel to the total height (plus tread thickness for visual coherence)
    newel_face.pushpull(TOTAL_HEIGHT + TREAD_THICKNESS) if newel_face.valid?

    # --- 2. Treads ---
    treads_group = create_solid_group(assembly_entities, "Treads_Assembly")
    apply_color(treads_group, "White") # Default color for treads

    # Total angular sweep for the entire staircase.
    # This is (NUM_STEPS / STEPS_PER_REVOLUTION) revolutions * 360 degrees.
    total_angular_sweep = NUM_STEPS * ANGLE_PER_STEP 
    
    # Starting angle for the first step (e.g., along the X-axis for consistency)
    start_angle_offset = 0.degrees 

    (0...NUM_STEPS).each do |i|
      step_group = create_solid_group(treads_group.entities, "Step_#{i+1}")
      step_entities = step_group.entities

      current_base_z = i * RISER_HEIGHT # Z-coordinate for the bottom of the current tread
      current_start_angle = start_angle_offset + (i * ANGLE_PER_STEP)
      current_end_angle = current_start_angle + ANGLE_PER_STEP

      # Define points for the wedge-shaped tread at its base (Z = current_base_z)
      # Inner-front point (closest to newel, at current_start_angle)
      pt1 = Geom::Point3d.new(NEWEL_RADIUS * Math.cos(current_start_angle), 
                              NEWEL_RADIUS * Math.sin(current_start_angle), 
                              current_base_z)
      # Outer-front point
      pt2 = Geom::Point3d.new(OUTER_TREAD_RADIUS * Math.cos(current_start_angle), 
                              OUTER_TREAD_RADIUS * Math.sin(current_start_angle), 
                              current_base_z)
      # Outer-back point
      pt3 = Geom::Point3d.new(OUTER_TREAD_RADIUS * Math.cos(current_end_angle), 
                              OUTER_TREAD_RADIUS * Math.sin(current_end_angle), 
                              current_base_z)
      # Inner-back point
      pt4 = Geom::Point3d.new(NEWEL_RADIUS * Math.cos(current_end_angle), 
                              NEWEL_RADIUS * Math.sin(current_end_angle), 
                              current_base_z)

      face = step_entities.add_face([pt1, pt2, pt3, pt4])
      face.pushpull(TREAD_THICKNESS) if face.valid?
    end

    # --- 3. Handrail ---
    handrail_group = create_solid_group(assembly_entities, "Handrail")
    apply_color(handrail_group, "Wood")
    
    # Calculate the radius for the handrail's centerline.
    # It's offset from the outer edge of the tread.
    handrail_centerline_radius = OUTER_TREAD_RADIUS - HANDRAIL_OFFSET_FROM_OUTER_EDGE - (HANDRAIL_WIDTH / 2)

    handrail_path_points = []
    
    # Loop for each step level (including the start at Z=0 and end at TOTAL_HEIGHT)
    # The handrail starts before the first step and ends after the last.
    # For a smoother start/end, we can extend the path slightly beyond the first/last step.
    # Let's generate points from 0 to NUM_STEPS, plus one extra for the final landing.
    
    # Calculate total revolutions to determine final angle.
    num_revolutions_actual = (NUM_STEPS.to_f / STEPS_PER_REVOLUTION.to_f)
    total_revolutions_angle = num_revolutions_actual * 360.degrees
    
    # We will go from the ground level (Z=0) up to TOTAL_HEIGHT.
    # The handrail height reference is from the *tread surface*.
    # So, at Z=0, the first tread surface is at TREAD_THICKNESS. The handrail should start from 0 + HANDRAIL_HEIGHT_FROM_TREAD.
    
    # Point at the bottom start of the staircase (before first tread)
    z_start = 0 + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)
    x_start = handrail_centerline_radius * Math.cos(start_angle_offset)
    y_start = handrail_centerline_radius * Math.sin(start_angle_offset)
    handrail_path_points << Geom::Point3d.new(x_start, y_start, z_start)

    # Generate points for each step
    (0..NUM_STEPS).each do |i| # Go up to NUM_STEPS (final landing level)
      current_angle = start_angle_offset + (i * ANGLE_PER_STEP)
      current_z = (i * RISER_HEIGHT) + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)

      x = handrail_centerline_radius * Math.cos(current_angle)
      y = handrail_centerline_radius * Math.sin(current_angle)
      handrail_path_points << Geom::Point3d.new(x, y, current_z)
    end
    
    # Create the handrail geometry
    create_handrail(assembly_entities, handrail_path_points, "Spiral_Handrail")

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(spiral_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
SpiralStairsGenerator.generate_spiral_stairs

(eval):3: warning: already initialized constant SpiralStairsGenerator::TOTAL_HEIGHT
(eval):3: warning: previous definition of TOTAL_HEIGHT was here
(eval):4: warning: already initialized constant SpiralStairsGenerator::NUM_STEPS
(eval):4: warning: previous definition of NUM_STEPS was here
(eval):5: warning: already initialized constant SpiralStairsGenerator::STEPS_PER_REVOLUTION
(eval):5: warning: previous definition of STEPS_PER_REVOLUTION was here
(eval):6: warning: already initialized constant SpiralStairsGenerator::NEWEL_RADIUS
(eval):6: warning: previous definition of NEWEL_RADIUS was here
(eval):7: warning: already initialized constant SpiralStairsGenerator::OUTER_TREAD_RADIUS
(eval):7: warning: previous definition of OUTER_TREAD_RADIUS was here
(eval):8: warning: already initialized constant SpiralStairsGenerator::TREAD_THICKNESS
(eval):8: warning: previous definition of TREAD_THICKNESS was here
(eval):11: warning: already initialized constant SpiralStairsGenerator::HANDRAIL_HEIGHT_FROM_TREAD
(eval):11: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):12: warning: already initialized constant SpiralStairsGenerator::HANDRAIL_WIDTH
(eval):12: warning: previous definition of HANDRAIL_WIDTH was here
(eval):13: warning: already initialized constant SpiralStairsGenerator::HANDRAIL_DEPTH
(eval):13: warning: previous definition of HANDRAIL_DEPTH was here
(eval):14: warning: already initialized constant SpiralStairsGenerator::HANDRAIL_OFFSET_FROM_OUTER_EDGE
(eval):14: warning: previous definition of HANDRAIL_OFFSET_FROM_OUTER_EDGE was here
(eval):17: warning: already initialized constant SpiralStairsGenerator::RISER_HEIGHT
(eval):17: warning: previous definition of RISER_HEIGHT was here
(eval):18: warning: already initialized constant SpiralStairsGenerator::ANGLE_PER_STEP
(eval):18: warning: previous definition of ANGLE_PER_STEP was here
#<ArgumentError: Cannot create unit vector from zero length vector>
(eval):111:in `axes'
(eval):111:in `create_handrail'
(eval):252:in `generate_spiral_stairs'
(eval):266:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above step nosing line

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `handrail_x_pos_offset` is the X-coordinate for the centerline of the handrail
  # Path points will define the CENTER of the handrail's cross-section.
  def self.generate_handrail_path_points(flight_x_offset, flight_y_base, flight_z_base,
                                         num_steps, direction_y, handrail_x_pos_offset)
    path_points = []
    
    # Start point on the ground plane, at the front of the first riser.
    # Z for handrail center at this level: flight_z_base (ground) + HANDRAIL_HEIGHT_FROM_TREAD (to top) - (HANDRAIL_DEPTH / 2) (to center)
    path_points << Geom::Point3d.new(handrail_x_pos_offset, flight_y_base,
                                     flight_z_base + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2))

    # Points above the nosing of each subsequent step
    (0...num_steps).each do |i|
      # Y-coordinate at the nosing of step (i+1)
      step_nosing_y = flight_y_base + ((i + 1) * TREAD_DEPTH * direction_y)
      # Z-coordinate at the nosing of step (i+1)
      step_nosing_z = flight_z_base + (i + 1) * RISER_HEIGHT
      
      # Handrail center Z-coordinate above this nosing
      handrail_center_z = step_nosing_z + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)
      
      path_points << Geom::Point3d.new(handrail_x_pos_offset, step_nosing_y, handrail_center_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # 1. Create the path edges
    path_edges = group_entities.add_curve(path_points)
    unless path_edges && path_edges.length > 0 # A path needs at least one edge (two points)
      puts "Error: Invalid path for handrail #{name}. Not enough points: #{path_points.length} points."
      handrail_group.erase!
      return nil
    end

    # 2. Define the profile face's vertices directly in their correct, transformed positions.
    # The path_points define the center line of the handrail.
    # The profile face needs to be perpendicular to the first segment of the path.

    # Get the vector of the first segment of the path.
    v_path = (path_points[1] - path_points[0]).normalize
    
    # Create a transformation to align the profile at the start of the path.
    # v_path will be the local Y-axis (extrusion direction).
    # We need local X and Z axes perpendicular to v_path.
    # `v_path.axes` returns an array: [v_path, perpendicular_x, perpendicular_z] (arbitrary order for latter two).
    tr_profile_alignment = Geom::Transformation.axes(path_points.first, v_path.axes[1], v_path, v_path.axes[2])

    # Define the profile points relative to its own local origin (0,0,0) and axes.
    # The profile will be centered on path_points.first, and lie in the local XZ plane.
    local_pts = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-left
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-right
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2), # Top-right
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)  # Top-left
    ]
    
    # Transform these local points to their absolute positions in the model space.
    absolute_pts = local_pts.map { |pt| pt.transform(tr_profile_alignment) }

    # Create the profile face in the group's entities
    profile_face = group_entities.add_face(absolute_pts)

    if profile_face.valid?
      # Ensure the face normal points *away* from the path's direction for FollowMe to work reliably.
      # If `profile_face.normal.dot(v_path)` is positive, the face is pointing along the path, so reverse it.
      if profile_face.normal.dot(v_path) > 0.001 # Use a small tolerance for comparison
        profile_face.reverse!
      end
      
      # Now use followme
      profile_face.followme(path_edges)
      return handrail_group
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile face creation failed or is invalid."
      handrail_group.erase!
      return nil
    end
  end
  
  # Helper to generate profile points for a stepped skirting face.
  # This returns a closed loop of points representing the side profile of the skirting.
  def self.generate_skirting_profile_points(flight_start_x, flight_start_y, flight_start_z,
                                              num_steps, direction_y, is_inner)
    profile_points = []
    x_pos = is_inner ? flight_start_x : flight_start_x + STAIR_WIDTH
    
    # 1. Start at the bottom-front corner (ground level for this flight segment)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z)

    # 2. Go up vertically to the top-front corner (skirting height at ground level)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z + SKIRTING_HEIGHT_ABOVE_NOSING)

    # 3. Trace the top stepped edge of the skirting (above the nosings)
    (0...num_steps).each do |i|
      y_tread_nosing = flight_start_y + (i + 1) * TREAD_DEPTH * direction_y
      z_tread_nosing = flight_start_z + (i + 1) * RISER_HEIGHT
      profile_points << Geom::Point3d.new(x_pos, y_tread_nosing, z_tread_nosing + SKIRTING_HEIGHT_ABOVE_NOSING)
    end
    
    # 4. Now trace the bottom stepped edge, going from the end of the flight back to the start.
    # Start from the bottom-back of the last riser (where it meets the landing/next segment)
    # The last riser's base point will be at Z = (NUM_STEPS_PER_FLIGHT) * RISER_HEIGHT
    # And Y = (NUM_STEPS_PER_FLIGHT) * TREAD_DEPTH * direction_y

    # First point on the way back down (bottom of the last riser)
    y_last_riser_base = flight_start_y + num_steps * TREAD_DEPTH * direction_y
    z_last_riser_base = flight_start_z + num_steps * RISER_HEIGHT
    profile_points << Geom::Point3d.new(x_pos, y_last_riser_base, z_last_riser_base)
    
    (num_steps - 1).downto(0) do |i|
      # This is the point at the base of riser (i+1) from the top (or riser `i` from the ground, where `i` is current step index)
      y_riser_base = flight_start_y + (i * TREAD_DEPTH * direction_y)
      z_riser_base = flight_start_z + (i * RISER_HEIGHT)
      profile_points << Geom::Point3d.new(x_pos, y_riser_base, z_riser_base)
    end
    
    # The last point added by the loop for i=0 is (x_pos, flight_start_y, flight_start_z) which is our first point.
    # To ensure a clean closed loop for `add_face` (no duplicate start/end point), remove the last point if it matches the first.
    if profile_points.last == profile_points.first
      profile_points.pop
    end
    
    return profile_points
  end

  # Helper to create a skirting by push-pulling a profile face
  def self.create_skirting(entities_collection, profile_points, extrusion_dir_unit_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    face = group_entities.add_face(profile_points)

    if face.valid?
      # Determine the extrusion distance based on face normal relative to desired direction.
      # `extrusion_dir_unit_vector` defines the desired outward direction.
      # If face normal is generally aligned with `extrusion_dir_unit_vector`, pushpull by `SKIRTING_THICKNESS`.
      # Otherwise, pushpull by `-SKIRTING_THICKNESS`.
      if face.normal.dot(extrusion_dir_unit_vector).abs < 0.001
         puts "Warning: Skirting face normal is nearly perpendicular to extrusion vector for #{name}. Check points."
         skirting_group.erase!
         return nil
      elsif face.normal.dot(extrusion_dir_unit_vector) > 0 # Face normal points in the desired direction
        face.pushpull(SKIRTING_THICKNESS)
      else # Face normal points opposite to the desired direction
        face.pushpull(-SKIRTING_THICKNESS)
      end
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "White") # Matching the image: First flight is white
    
    # Coordinates for the first flight
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    # This flight starts at the landing's Z-level, is shifted in X, and recedes along the Y-axis.
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "Blue") # Matching the image: Second flight is blue

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    # The second flight starts precisely from the far edge of the landing, stepping backwards.
    flight2_start_y = landing_y_end
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent (bottom of landing)

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # The Z-level for handrails over the landing is constant.
    landing_handrail_z = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)

    # X-offsets for the center of the handrails
    handrail_x_outer_f1 = STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_inner_f1 = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2 
    handrail_x_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    # --- Outer Handrail Path ---
    outer_rail_points = []
    
    # Part A: First Flight Section (from ground to landing level)
    outer_rail_points.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                            NUM_STEPS_PER_FLIGHT, 1, handrail_x_outer_f1))
    
    # Part B: Outer Landing Horizontal Segment (across X, at Y=landing_y_start)
    # The last point from Part A is `(handrail_x_outer_f1, landing_y_start, landing_handrail_z)`
    outer_rail_points << Geom::Point3d.new(handrail_x_outer_f2, outer_rail_points.last.y, landing_handrail_z)
    
    # Part C: Outer Landing Turn Segment (along Y) - connecting to start of second flight.
    # From `(handrail_x_outer_f2, landing_y_start, landing_handrail_z)` to `(handrail_x_outer_f2, landing_y_end, landing_handrail_z)`
    outer_rail_points << Geom::Point3d.new(handrail_x_outer_f2, flight2_start_y, landing_handrail_z) # flight2_start_y is landing_y_end
    
    # Part D: Second Flight Section (from landing level down to ground)
    # The first point generated by `generate_handrail_path_points` for F2 is `(handrail_x_outer_f2, flight2_start_y, landing_handrail_z)`.
    # This is exactly the last point added in Part C, so we skip it to avoid duplication.
    outer_rail_points.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                            NUM_STEPS_PER_FLIGHT, -1, handrail_x_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_rail_points, "Outer_Handrail")

    # --- Inner Handrail Path ---
    inner_rail_points = []

    # Part A: First Flight Inner Section
    inner_rail_points.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                            NUM_STEPS_PER_FLIGHT, 1, handrail_x_inner_f1))
    
    # Part B: Inner Landing Turn (Y-segment)
    # From end of F1 rail `(handrail_x_inner_f1, inner_rail_points.last.y, landing_handrail_z)`
    # to the inner corner of the gap: `(handrail_x_inner_f1, landing_y_end - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2), landing_handrail_z)`
    # NOTE: Offset for the inner corner needs to be `(landing_depth_y - (offset_from_edge + half_width))` from the 'y_start' of the landing.
    inner_gap_y_pos = landing_y_end - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2)
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f1, inner_gap_y_pos, landing_handrail_z)

    # Part C: Inner Landing Horizontal Segment (across X - the gap itself)
    # Across the gap to align with F2 inner rail starting X
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f2, inner_gap_y_pos, landing_handrail_z)

    # Part D: Inner Landing Turn (Y-segment)
    # From the end of Part C to the starting Y of F2 inner rail (`flight2_start_y`)
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f2, flight2_start_y, landing_handrail_z)

    # Part E: Second Flight Inner Section
    # Again, skip first point as it's a duplicate of last point in Part D
    inner_rail_points.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                            NUM_STEPS_PER_FLIGHT, -1, handrail_x_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_rail_points, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # --- Generate Skirtings ---
    skirting_color = "Wood" 
    
    # First Flight Outer Skirting (profile at X=STAIR_WIDTH, extrude +X)
    outer_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, false) # is_inner = false means outer edge
    create_skirting(assembly_entities, outer_skirting_f1_profile, Geom::Vector3d.new(1, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting (profile at X=0, extrude -X)
    inner_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, true) # is_inner = true means inner edge
    create_skirting(assembly_entities, inner_skirting_f1_profile, Geom::Vector3d.new(-1, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing, extrude -Y)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -1, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing, extrude +Y)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, 1, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing, extrude +X)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(1, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Second Flight Outer Skirting (profile at X=flight2_x_offset + STAIR_WIDTH, extrude +X)
    outer_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, false)
    create_skirting(assembly_entities, outer_skirting_f2_profile, Geom::Vector3d.new(1, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting (profile at X=flight2_x_offset, extrude -X)
    inner_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, true)
    create_skirting(assembly_entities, inner_skirting_f2_profile, Geom::Vector3d.new(-1, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

=> #<Sketchup::View:0x000000001dac01d0>
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above step nosing line

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_position_offset` is the X-coordinate for the centerline of the handrail
  # path_points will define the CENTER of the handrail's cross-section.
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_position_offset)
    path_points = []
    
    # Starting point of the handrail for the flight
    # The handrail starts from ground level (Z=0) at the front edge of the first riser.
    # The Z-level for the center of the handrail at this point:
    # flight_start_z (ground) + HANDRAIL_HEIGHT_FROM_TREAD (to top) - (HANDRAIL_DEPTH / 2) (to center)
    
    # Path point for the *start* of the handrail before the first step
    path_points << Geom::Point3d.new(x_position_offset, flight_start_y, flight_start_z + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2))

    (0...num_steps).each do |i|
      # Calculate the Z-level for the top surface of the current tread, then adjust to handrail center Z.
      # Z of top-front edge of step (i+1) is (i+1) * RISER_HEIGHT from flight_start_z.
      # Tread nosing line is at (i+1)*RISER_HEIGHT.
      current_z_nosing = flight_start_z + (i + 1) * RISER_HEIGHT
      current_z_center = current_z_nosing + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)
      
      # Y-coordinate depends on direction: (i+1)*TREAD_DEPTH for front edge of step (i+1)
      current_y = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)

      path_points << Geom::Point3d.new(x_position_offset, current_y, current_z_center)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # 1. Create the path edges
    path_edges = group_entities.add_curve(path_points)
    unless path_edges && path_edges.length > 1 # A path needs at least two points (one edge)
      puts "Error: Invalid path for handrail #{name}. Not enough points: #{path_points.length} points."
      handrail_group.erase!
      return nil
    end

    # 2. Define the profile face's vertices directly in their correct, transformed positions.
    # The path_points define the center line of the handrail.
    # The profile face needs to be perpendicular to the first segment of the path.

    # Get the vector of the first segment of the path.
    v_path = (path_points[1] - path_points[0]).normalize
    
    # Get perpendicular vectors for the profile's local X (width) and Z (depth) axes.
    # SketchUp's `Vector3d#axes` returns a canonical set of perpendicular vectors,
    # given one vector (the first element of the array is the input vector, the other two are perpendicular).
    # We want `v_path` to be our local Y-axis for FollowMe's extrusion direction.
    # So, we need to pick two vectors from `v_path.axes` to be our local X and Z.
    # Let's use `v_path.axes.x` as the local X (width) and `v_path.axes.z` as the local Z (depth).
    
    local_xaxis = v_path.axes.x
    local_yaxis = v_path # This is our extrusion direction
    local_zaxis = v_path.axes.z # This will define the 'up/down' of the profile

    # Create a transformation to align the profile.
    # The origin for the profile is the first point of the path.
    tr_profile_alignment = Geom::Transformation.axes(path_points.first, local_xaxis, local_yaxis, local_zaxis)

    # Define the profile points relative to its own local origin (0,0,0) and axes.
    # The profile will be centered on path_points.first.
    local_pts = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-left
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-right
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2), # Top-right
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)  # Top-left
    ]
    
    # Transform these local points to their absolute positions in the model space.
    absolute_pts = local_pts.map { |pt| pt.transform(tr_profile_alignment) }

    # Create the profile face in the group's entities
    profile_face = group_entities.add_face(absolute_pts)

    if profile_face.valid?
      # Ensure the face normal points *away* from the path's direction for FollowMe to work reliably.
      # If `profile_face.normal.dot(v_path)` is positive, the face is pointing along the path, so reverse it.
      if profile_face.normal.dot(v_path) > 0.001 # Use a small tolerance for comparison
        profile_face.reverse!
      end
      
      # Now use followme
      profile_face.followme(path_edges)
      return handrail_group
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile face creation failed or is invalid."
      handrail_group.erase!
      return nil
    end
  end
  
  # Helper to generate the path points for a skirting on one side of a flight profile
  # `is_inner` determines if it's the inner (X=0) or outer (X=STAIR_WIDTH) skirting.
  # `direction_y` is +1 for first flight, -1 for second flight.
  def self.generate_skirting_profile_points(flight_start_x, flight_start_y, flight_start_z,
                                            num_steps, direction_y, is_inner)
    profile_points = []
    
    # X-position for this skirting edge
    x_pos = is_inner ? flight_start_x : flight_start_x + STAIR_WIDTH
    
    # 1. Starting bottom point (at ground level, aligned with first step's front)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z)

    # 2. Walk up the steps to define the profile (back of riser, top of tread)
    (0...num_steps).each do |i|
      current_z_riser_top = flight_start_z + (i + 1) * RISER_HEIGHT
      current_y_tread_back = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      current_y_tread_front = flight_start_y + (i * TREAD_DEPTH * direction_y)

      # Point at the top of the current riser (which is the back of the current tread)
      profile_points << Geom::Point3d.new(x_pos, current_y_tread_back, current_z_riser_top)
      
      # Point at the nosing line (top-front edge of the tread), offset for skirting height
      # Skirting goes up from nosing by SKIRTING_HEIGHT_ABOVE_NOSING
      profile_points << Geom::Point3d.new(x_pos, current_y_tread_back, current_z_riser_top + SKIRTING_HEIGHT_ABOVE_NOSING)
      profile_points << Geom::Point3d.new(x_pos, current_y_tread_front, current_z_riser_top + SKIRTING_HEIGHT_ABOVE_NOSING)
    end
    
    # 3. Add point for the last riser top (level with landing) for the skirting's top edge
    final_z_tread_top = flight_start_z + (num_steps + 1) * RISER_HEIGHT
    final_y_tread_back = flight_start_y + (num_steps * TREAD_DEPTH * direction_y)
    
    profile_points << Geom::Point3d.new(x_pos, final_y_tread_back, final_z_tread_top + SKIRTING_HEIGHT_ABOVE_NOSING)
    
    profile_points
  end

  # Helper to create a skirting by push-pulling a profile face
  def self.create_skirting(entities_collection, profile_points, extrusion_vector_dir, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    face = group_entities.add_face(profile_points)

    if face.valid?
      # Determine the extrusion distance based on face normal relative to desired direction.
      # `extrusion_vector_dir` defines the desired direction of outward extrusion.
      # If face normal is generally aligned with `extrusion_vector_dir`, pushpull by `SKIRTING_THICKNESS`.
      # Otherwise, pushpull by `-SKIRTING_THICKNESS`.
      if face.normal.dot(extrusion_vector_dir).abs < 0.001 # Face is parallel to extrusion vector - problem.
         puts "Warning: Skirting face normal is nearly perpendicular to extrusion vector for #{name}. Check points."
         skirting_group.erase!
         return nil
      elsif face.normal.dot(extrusion_vector_dir) > 0 # Face normal points in the desired direction
        face.pushpull(SKIRTING_THICKNESS)
      else # Face normal points opposite to the desired direction
        face.pushpull(-SKIRTING_THICKNESS)
      end
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "White") # Matching the image: First flight is white
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    # This flight starts at the landing's Z-level, is shifted in X, and recedes along the Y-axis.
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "Blue") # Matching the image: Second flight is blue

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    # The second flight starts precisely from the far edge of the landing, stepping backwards.
    flight2_start_y = landing_y_end
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent (bottom of landing)

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      # The 'front' edge of the current tread (closer to the landing).
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      # The 'back' edge of the current tread (further from the landing).
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Rails and Skirtings ---
    # Handrails: Use FollowMe for both inner and outer railings for all parts.
    
    # Railing geometry parameters
    handrail_x_offset_outer_f1 = STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2 
    
    # Outer Handrail Path
    outer_handrail_path = []
    # First Flight Outer
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    landing_handrail_outer_y = outer_handrail_path.last.y # Y-coord of the rail at landing level
    landing_handrail_outer_z = outer_handrail_path.last.z # Z-coord of the rail at landing level
    outer_handrail_path << Geom::Point3d.new(landing_x_end - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2, landing_handrail_outer_y, landing_handrail_outer_z)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    flight2_outer_handrail_x = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    # The first point of the second flight's rail is already covered by the landing segment.
    # So we generate the points for the second flight and skip the first one to avoid duplicates.
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, flight2_outer_handrail_x)[1..-1])

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail")

    # Inner Handrail Path (More complex due to U-turn)
    inner_handrail_path = []
    # First Flight Inner (Starts at X=0, +HANDRAIL_OFFSET)
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    # Landing Inner (Connects First flight inner to Second flight inner)
    # This involves a turn across the gap.
    inner_handrail_path_last_pt = inner_handrail_path.last
    landing_inner_handrail_z = inner_handrail_path_last_pt.z # Z-level is constant over landing

    # 1. Segment along Y: continues from first flight to the turn corner
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, landing_y_end - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2, landing_inner_handrail_z)
    # 2. Segment along X: crosses the gap
    inner_handrail_path << Geom::Point3d.new(flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2, landing_y_end - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2, landing_inner_handrail_z)
    # 3. Segment along Y: connects to the start of the second flight inner handrail
    inner_handrail_path << Geom::Point3d.new(flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2, landing_y_start + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2, landing_inner_handrail_z)
    
    # Second Flight Inner (Starts at flight2_x_offset, +HANDRAIL_OFFSET)
    flight2_inner_handrail_x = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    # Skip first point from generated path to avoid duplication with previous landing segment.
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, flight2_inner_handrail_x)[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # Skirtings: Create faces from profile points and pushpull
    skirting_color = "Wood" 
    
    # First Flight Outer Skirting (profile at X=STAIR_WIDTH, extrude +X)
    outer_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, false) # is_inner = false means outer edge
    create_skirting(assembly_entities, outer_skirting_f1_profile, Geom::Vector3d.new(1, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting (profile at X=0, extrude -X)
    inner_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, true) # is_inner = true means inner edge
    create_skirting(assembly_entities, inner_skirting_f1_profile, Geom::Vector3d.new(-1, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Skirtings (straight boards)
    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing, extrude -Y)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -1, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing, extrude +Y)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, 1, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing, extrude +X)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(1, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Second Flight Outer Skirting (profile at X=flight2_x_offset + STAIR_WIDTH, extrude +X)
    outer_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, false)
    create_skirting(assembly_entities, outer_skirting_f2_profile, Geom::Vector3d.new(1, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting (profile at X=flight2_x_offset, extrude -X)
    inner_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, true)
    create_skirting(assembly_entities, inner_skirting_f2_profile, Geom::Vector3d.new(-1, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
=> #<Sketchup::View:0x000000001dac01d0>
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above step nosing line

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    material = Sketchup.active_model.materials[color_name]
    unless material
      material = Sketchup.active_model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_position_offset, name_prefix)
    path_points = []
    # Start point of the handrail for the flight (below the first step's nosing)
    # The handrail starts from ground level, but its 'reference' is the step's nosing line.
    # Let's make it start horizontally at the first riser's bottom (Z=0).
    
    # Path point generation for flight
    (0..num_steps).each do |i|
      # Nosing line Z for step i (i=0 is the ground level below the first step)
      # Z of top-front edge of step (i) is i * RISER_HEIGHT
      # Vertical offset for handrail: HANDRAIL_HEIGHT_FROM_TREAD
      
      # Y-coordinate depends on direction
      # For first flight (direction_y = 1): (i * TREAD_DEPTH) for front edge
      # For second flight (direction_y = -1): (flight_start_y - i * TREAD_DEPTH) for front edge
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      current_z = flight_start_z + (i * RISER_HEIGHT) + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_position_offset, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Create the profile face for FollowMe
    profile_origin = path_points.first # Start at the first point of the path
    # Profile perpendicular to the path direction at the start
    # Assume path starts parallel to Y-axis or X-axis
    
    # Create profile at origin, then transform it to the path start and orient.
    # For a path along Y, profile needs to be in XZ plane.
    # For a path along X, profile needs to be in YZ plane.
    # Our paths are mainly along Y, so XZ profile.
    
    # Create a temporary component definition for the profile
    model = Sketchup.active_model
    profile_comp_def = model.definitions.add("HandrailProfile_#{name}")
    profile_entities = profile_comp_def.entities
    
    pts = [
      Geom::Point3d.new(0, -HANDRAIL_WIDTH / 2, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(0, HANDRAIL_WIDTH / 2, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(0, HANDRAIL_WIDTH / 2, HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(0, -HANDRAIL_WIDTH / 2, HANDRAIL_DEPTH / 2)
    ]
    profile_face = profile_entities.add_face(pts)
    
    # Position the profile component instance at the start of the path
    # and align it with the path.
    # For `followme`, we just need a face in the entities context.
    # We can create a face directly in the current entities,
    # then move/rotate it. The origin of the profile matters for `followme`.
    
    # Let's make the profile in the XZ plane for paths along Y.
    # Profile points define a rectangle centered on the origin, then moved.
    profile_points = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(HANDRAIL_WIDTH / 2, 0, HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, HANDRAIL_DEPTH / 2)
    ]
    
    # Move the profile to the first path point.
    t = Geom::Transformation.translation(path_points.first)
    
    # This face will be created directly in `handrail_group.entities`
    # and then used for followme.
    profile_face_for_followme = group_entities.add_face(profile_points)
    profile_face_for_followme.transform!(t)

    # Use followme
    path_edges = group_entities.add_ngon(Geom::Point3d.new(0,0,0), Geom::Vector3d.new(0,0,1), 1, 0) # dummy edges
    path_edges = group_entities.add_curve(path_points)
    
    if profile_face_for_followme.valid? && path_edges.count > 0
      profile_face_for_followme.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile or path invalid."
      handrail_group.erase!
      return nil
    end
    handrail_group
  end
  
  # Helper to generate the path points for a skirting on one side of a flight
  # `is_inner` determines if it's the inner (X=0) or outer (X=STAIR_WIDTH) skirting.
  # `direction_y` is +1 for first flight, -1 for second flight.
  def self.generate_skirting_profile_points(flight_start_x, flight_start_y, flight_start_z,
                                            num_steps, direction_y, is_inner, name_prefix)
    profile_points = []
    
    # Starting bottom point (at ground level, aligned with first step's front)
    x_pos = is_inner ? flight_start_x : flight_start_x + STAIR_WIDTH
    
    # Point at ground level, front of first step
    current_y_base = flight_start_y
    profile_points << Geom::Point3d.new(x_pos, current_y_base, flight_start_z)

    # Walk up the steps to define the profile (back of riser, top of tread)
    (0...num_steps).each do |i|
      current_z = flight_start_z + (i + 1) * RISER_HEIGHT
      current_y = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)

      # Back of the riser (at current_y, up to current_z)
      profile_points << Geom::Point3d.new(x_pos, current_y_base + (i * TREAD_DEPTH * direction_y), current_z)

      # Top of the tread (at current_y, up to current_z)
      profile_points << Geom::Point3d.new(x_pos, current_y, current_z)
    end
    
    # Add point for the last riser top (level with landing)
    final_z = flight_start_z + (num_steps + 1) * RISER_HEIGHT
    final_y = flight_start_y + (num_steps * TREAD_DEPTH * direction_y)
    profile_points << Geom::Point3d.new(x_pos, final_y, final_z)

    profile_points
  end

  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      face.pushpull(extrusion_vector.length * (extrusion_vector.x > 0 || extrusion_vector.y > 0 || extrusion_vector.z > 0 ? 1 : -1))
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue") # Applying color to the group for visibility
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    # This flight starts at the landing's Z-level, is shifted in X, and recedes along the Y-axis.
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White") # Applying color to the group for visibility

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Start from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      # The 'front' edge of the current tread (closer to the landing).
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      # The 'back' edge of the current tread (further from the landing).
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Rails and Skirtings ---
    # Handrails: Use FollowMe for both inner and outer railings for all parts.
    # The actual path points for FollowMe need to be carefully constructed.

    # Railing geometry parameters
    handrail_x_offset_outer = STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2 # for the first flight's inner edge
    
    # Outer Handrail Path
    outer_handrail_path = []
    # First Flight Outer
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer, "Flight1_Outer"))
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    landing_handrail_outer_y = outer_handrail_path.last.y
    landing_handrail_outer_z = outer_handrail_path.last.z
    outer_handrail_path << Geom::Point3d.new(landing_x_end - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2, landing_handrail_outer_y, landing_handrail_outer_z)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    flight2_outer_handrail_x = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, flight2_outer_handrail_x, "Flight2_Outer")[1..-1]) # Skip first point to avoid duplication

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail")

    # Inner Handrail Path (More complex due to U-turn)
    inner_handrail_path = []
    # First Flight Inner (Starts at X=0, +HANDRAIL_OFFSET)
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner, "Flight1_Inner"))
    
    # Landing Inner (Connects First flight inner to Second flight inner)
    # This involves a turn. The inner railing turns with the landing.
    # It starts at (handrail_x_offset_inner, inner_handrail_path.last.y, inner_handrail_path.last.z)
    # It then needs to go straight for a bit, then turn 90 degrees, then straight.
    # Let's simplify the turn for a straight corner for now.
    inner_handrail_path_last_pt = inner_handrail_path.last
    landing_inner_handrail_start_x = inner_handrail_path_last_pt.x
    landing_inner_handrail_start_y = inner_handrail_path_last_pt.y
    landing_inner_handrail_start_z = inner_handrail_path_last_pt.z

    # The inner handrail path over the landing:
    # 1. Straight segment along Y (until inner edge of landing along Y)
    inner_handrail_path << Geom::Point3d.new(landing_inner_handrail_start_x, landing_y_end - HANDRAIL_OFFSET_FROM_EDGE, landing_inner_handrail_start_z)
    # 2. Straight segment along X (across the gap)
    inner_handrail_path << Geom::Point3d.new(flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE, landing_y_end - HANDRAIL_OFFSET_FROM_EDGE, landing_inner_handrail_start_z)
    # 3. Straight segment along Y (connecting to the start of the second flight inner handrail)
    inner_handrail_path << Geom::Point3d.new(flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE, landing_y_start + HANDRAIL_OFFSET_FROM_EDGE, landing_inner_handrail_start_z) # Connect to second flight start
    
    # Second Flight Inner (Starts at flight2_x_offset, +HANDRAIL_OFFSET)
    flight2_inner_handrail_x = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, flight2_inner_handrail_x, "Flight2_Inner")[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # Skirtings: Create faces from profile points and pushpull
    skirting_color = "Wood" # Could be a different material
    
    # First Flight Outer Skirting
    outer_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, false, "Flight1_Outer_Skirting")
    create_skirting(assembly_entities, outer_skirting_f1_profile, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting
    inner_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, true, "Flight1_Inner_Skirting")
    create_skirting(assembly_entities, inner_skirting_f1_profile, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Skirtings (straight boards)
    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Landing Inner Skirting (along X=0, across Y-depth for the first flight's connection, but the gap side is a wall)
    # The inner skirting for the landing is effectively the 'wall' of the gap.
    # It runs along X=0 for the first flight. Then along X=flight2_x_offset for the second flight.
    # The part between X=0 and X=flight2_x_offset on the inner side of the landing (along Y-axis) is covered by the Landing Front Skirting and Landing Back Skirting.
    # So, we need only a skirting for the central "wall" of the U-turn if it's not a complete open space.
    # For simplicity, if we have inner rails, we will assume an open space, thus no inner wall skirting on landing.
    # The previous skirtings cover the outer edges.

    # Second Flight Outer Skirting
    outer_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, false, "Flight2_Outer_Skirting")
    create_skirting(assembly_entities, outer_skirting_f2_profile, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting
    inner_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, true, "Flight2_Inner_Skirting")
    create_skirting(assembly_entities, inner_skirting_f2_profile, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
#<NoMethodError: undefined method `transform!' for #<Sketchup::Face:0x0000000027d52a88>>
(eval):145:in `create_handrail'
(eval):306:in `generate_stairs'
(eval):421:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGenerator
  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    # Define standard dimensions in millimeters.
    # SketchUp's built-in `Numeric` extensions (like .mm) automatically convert values.
    riser_height = 175.mm # Vertical height of each step
    tread_depth  = 260.mm # Horizontal depth of each step
    stair_width  = 900.mm # Width of each stair flight
    num_steps_per_flight = 11

    # Dimensions for the U-turn landing:
    # Its depth along the Y-axis (direction of the first flight)
    landing_depth_y = stair_width
    # The width of the 'hole' in the U-shape, i.e., the gap between the two flights.
    gap_width_x = stair_width

    # Start an undo operation for better user experience.
    model.start_operation("Generate U-Shape Stairs", true)

    # Create a group to contain all the stair geometry.
    stairs_group = entities.add_group
    group_entities = stairs_group.entities

    # --- 1. First Flight ---
    # This flight builds from (0,0,0) upwards along the Y-axis.
    (0...num_steps_per_flight).each do |i|
      # Calculate the Z-level for the top surface of the current tread.
      # The first step (i=0) has its top at 1*riser_height.
      current_tread_z = (i + 1) * riser_height
      
      # Define the Y-range for the current tread.
      # The first step (i=0) covers Y from 0*tread_depth to 1*tread_depth.
      current_tread_y_front = i * tread_depth
      current_tread_y_back  = (i + 1) * tread_depth

      # Define the points for the top face of the tread.
      # These points define a rectangle in the XY plane, at current_tread_z.
      pt1 = Geom::Point3d.new(0, current_tread_y_front, current_tread_z)
      pt2 = Geom::Point3d.new(stair_width, current_tread_y_front, current_tread_z)
      pt3 = Geom::Point3d.new(stair_width, current_tread_y_back, current_tread_z)
      pt4 = Geom::Point3d.new(0, current_tread_y_back, current_tread_z)

      # Create the face and push-pull it downwards to form the step block (tread + riser).
      face = group_entities.add_face([pt1, pt2, pt3, pt4])
      face.pushpull(-riser_height)
    end

    # --- 2. Landing ---
    # The landing is effectively the (num_steps_per_flight + 1)-th step in terms of height.
    # It bridges the gap between the first and second flights.
    landing_z_level = (num_steps_per_flight + 1) * riser_height
    
    # Y-coordinates for the landing. It starts where the first flight ends and extends by landing_depth_y.
    landing_y_start = num_steps_per_flight * tread_depth
    landing_y_end = landing_y_start + landing_depth_y 
    
    # X-coordinates for the landing. It spans both flights and the central gap.
    landing_x_start = 0
    landing_x_end = stair_width + gap_width_x + stair_width # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1 = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2 = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3 = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4 = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    # Create the landing face and push-pull it downwards.
    face = group_entities.add_face([pt1, pt2, pt3, pt4])
    face.pushpull(-riser_height)
    
    # --- 3. Second Flight ---
    # This flight starts at the landing's Z-level, is shifted in X, and recedes along the Y-axis.
    
    # X-offset for the second flight. Its inner edge aligns with the outer edge of the gap.
    x_offset_second_flight = stair_width + gap_width_x
    
    # The Z-level at which the second flight begins its ascent (top of the landing).
    z_start_second_flight = landing_z_level 
    
    # The Y-coordinate of the 'back' edge of the landing, from which the second flight steps back.
    y_start_second_flight = landing_y_end 

    (0...num_steps_per_flight).each do |j|
      # Calculate the Z-level for the top surface of the current tread.
      # The first step of the second flight (j=0) has its top at z_start_second_flight + 1*riser_height.
      current_tread_z = z_start_second_flight + (j + 1) * riser_height
      
      # Define the Y-coordinates for the tread, receding from y_start_second_flight.
      # The 'front' edge of the current tread (closer to the landing).
      tread_y_front = y_start_second_flight - j * tread_depth
      # The 'back' edge of the current tread (further from the landing).
      tread_y_back = y_start_second_flight - (j + 1) * tread_depth

      # Define the points for the top face of the tread, with the X-offset.
      pt1 = Geom::Point3d.new(x_offset_second_flight, tread_y_back, current_tread_z)
      pt2 = Geom::Point3d.new(x_offset_second_flight + stair_width, tread_y_back, current_tread_z)
      pt3 = Geom::Point3d.new(x_offset_second_flight + stair_width, tread_y_front, current_tread_z)
      pt4 = Geom::Point3d.new(x_offset_second_flight, tread_y_front, current_tread_z)

      # Create the face and push-pull it downwards.
      face = group_entities.add_face([pt1, pt2, pt3, pt4])
      face.pushpull(-riser_height)
    end

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(stairs_group)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGenerator.generate_stairs

=> #<Sketchup::View:0x000000001dac01d0>
Licensing system loaded successfully
✅ AutoNestCut Module Loaded [10:35:05]
DEBUG: Generated 4 boards successfully
DEBUG: ReportGenerator.generate_report_data called with 4 boards
DEBUG: Report settings - currency: SAR, units: mm, precision: 0
DEBUG: Generated report data:
  - Parts placed: 13
  - Unique part types: 13
  - Boards: 4
  - Total project cost: 1360
DEBUG: Sending report data to frontend:
  - Diagrams count: 4
  - Report summary: {:total_parts_instances=>13, :total_unique_part_types=>13, :total_boards=>4, :total_stock_area=>3840000, :total_used_area=>2525300, :total_waste_area=>1314700, :overall_waste_percentage=>34.24, :overall_efficiency=>65.75999999999999, :total_project_cost=>1360, :currency=>"SAR", :units=>"mm", :precision=>0}
  - Parts placed count: 13
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The handrail starts at the Z-level of the first step's nosing, relative to ground.
    # Nosing Z for step `i` is `(i+1) * RISER_HEIGHT`
    # Handrail Z is `nosing_Z + HANDRAIL_HEIGHT_FROM_TREAD`

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      current_z = flight_start_z + (i * RISER_HEIGHT) + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    return nil if path_points.length < 2

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Calculate initial orientation for the profile face.
    # The path generally moves along Y. So the profile should be in the XZ plane.
    # SketchUp's FollowMe expects the profile to be at the start of the path and oriented perpendicular.
    # We create the profile face at origin and then move it to the first path point.
    
    # Create an initial face at origin, then transform it
    temp_face = group_entities.add_face(profile_points_relative)
    if !temp_face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed."
      handrail_group.erase!
      return nil
    end

    # Orient the profile correctly at the start of the path.
    # The first segment of the path defines the direction.
    path_start_pt = path_points.first
    path_end_pt = path_points[1]
    path_vector = path_end_pt - path_start_pt
    
    # Default orientation: profile in XZ plane, normal along Y.
    # If path is along Y, this is correct. If path is along X, it needs rotation.
    # Our paths for flights are along Y. Landing segments can be along X or Y.
    # For now, let's assume the path starts along Y.
    
    # Transform the profile to the start of the path
    tr_move = Geom::Transformation.translation(path_start_pt)
    temp_face.transform!(tr_move)
    
    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if temp_face.valid? && path_edges.count > 0
      temp_face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile or path invalid."
      handrail_group.erase!
      return nil
    end
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Define the stepped bottom edge of the skirting (where it meets the stairs)
    # The first point is at the front-top of the first tread (or ground level if starting from 0)
    # For step `i` (0-indexed), tread top is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # For point *before* the first riser (i=0): (x_side, flight_start_y, flight_start_z)
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    (0...num_steps).each do |i|
      # Point at the base of the current riser (Y = previous tread front, Z = current tread top)
      y_tread_front = flight_start_y + (i * TREAD_DEPTH * direction_y)
      z_riser_base = flight_start_z + (i * RISER_HEIGHT)
      profile_pts << Geom::Point3d.new(x_side, y_tread_front, z_riser_base)
      
      # Point at the top of the current riser (Y = current tread front, Z = next tread top)
      z_riser_top = flight_start_z + ((i+1) * RISER_HEIGHT)
      profile_pts << Geom::Point3d.new(x_side, y_tread_front, z_riser_top)
    end
    
    # Add point at the top of the last riser (level with landing base)
    final_y_stepped = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    final_z_stepped = flight_start_z + NUM_STEPS_PER_FLIGHT * RISER_HEIGHT
    profile_pts << Geom::Point3d.new(x_side, final_y_stepped, final_z_stepped)

    # 2. Define the straight top edge of the skirting
    # This line runs parallel to the "line of the step nosings", offset upwards.
    # Nosing line start: (Y=flight_start_y, Z=flight_start_z + RISER_HEIGHT) -- this is the front-top of the 1st step
    # Nosing line end: (Y=final_y_stepped, Z=flight_start_z + (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT)
    
    top_edge_start_y = flight_start_y
    top_edge_start_z = flight_start_z + RISER_HEIGHT + SKIRTING_HEIGHT_ABOVE_NOSING

    top_edge_end_y = final_y_stepped
    top_edge_end_z = final_z_stepped + RISER_HEIGHT + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start
    profile_pts << Geom::Point3d.new(x_side, top_edge_end_y, top_edge_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_start_y, top_edge_start_z)
    
    # The loop is closed by add_face connecting the last point to the first.
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      face.pushpull(extrusion_vector) # Use vector directly
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path
    outer_handrail_path = []
    # First Flight Outer
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    # Start of landing segment is end of first flight path.
    # End of landing segment aligns with start of second flight path.
    landing_handrail_outer_y_level = outer_handrail_path.last.y # Y position remains constant across landing
    landing_handrail_outer_z_level = outer_handrail_path.last.z # Z position remains constant across landing
    
    # Point at the far X-end of the landing, aligned with outer edge of second flight.
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, landing_handrail_outer_y_level, landing_handrail_outer_z_level)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    # Skip first point of flight2 path to avoid duplication as it's covered by the landing segment.
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail")

    # Inner Handrail Path (More complex due to U-turn around the gap)
    inner_handrail_path = []
    # First Flight Inner
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    # Landing Inner U-Turn Path
    # This path defines the cornering of the inner handrail.
    # P1: End of first flight inner rail (already in inner_handrail_path)
    # P2: Straight segment along Y to the inner-front corner of the gap.
    # P3: Straight segment along X across the gap.
    # P4: Straight segment along Y to connect to the second flight's inner rail.
    
    # Common Z level for the landing handrails
    landing_rail_z = inner_handrail_path.last.z

    # Y-coordinate of the 'front' inner edge of the gap (where flight 1 ends)
    y_gap_front = landing_y_start # Same as flight1_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH

    # Y-coordinate of the 'back' inner edge of the gap (where flight 2 starts receding)
    y_gap_back = landing_y_end # Same as flight2_start_y

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    # The Y position for the turn is `landing_y_end` offset by `HANDRAIL_OFFSET_FROM_EDGE` (from inner edge of landing/gap).
    # Since `landing_y_end` is the 'back' edge of the full landing, the offset needs to be from that edge.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    # The X position is `flight2_x_offset` (start of second flight) offset inwards.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 3: Moves along Y to connect to the start of the second flight's inner handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_front + (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)
    
    # Second Flight Inner (Skip first point to avoid duplication)
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # --- Generate Skirtings ---
    skirting_color = "DarkGrey" # Could be a different material

    # First Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight1_start_x + STAIR_WIDTH
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight1_start_x (which is 0)
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Landing Gap Left Skirting (along X=STAIR_WIDTH, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Gap_Left_Skirting" }, skirting_color)

    # Landing Gap Right Skirting (along X=STAIR_WIDTH+GAP_WIDTH_X, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Gap_Right_Skirting" }, skirting_color)


    # Second Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight2_x_offset + STAIR_WIDTH
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight2_x_offset
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
#<NoMethodError: undefined method `transform!' for #<Sketchup::Face:0x0000000028533ae0>>
(eval):136:in `create_handrail'
(eval):314:in `generate_stairs'
(eval):460:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The handrail starts at the Z-level of the first step's nosing, relative to ground.
    # Nosing Z for step `i` is `(i+1) * RISER_HEIGHT`
    # Handrail Z is `nosing_Z + HANDRAIL_HEIGHT_FROM_TREAD`

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      current_z = flight_start_z + (i * RISER_HEIGHT) + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    return nil if path_points.length < 2

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Calculate initial orientation for the profile face.
    # The path generally moves along Y. So the profile should be in the XZ plane.
    # SketchUp's FollowMe expects the profile to be at the start of the path and oriented perpendicular.
    # We create the profile face at origin and then move it to the first path point.
    
    # Create an initial face at origin, then transform it
    temp_face = group_entities.add_face(profile_points_relative)
    if !temp_face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed."
      handrail_group.erase!
      return nil
    end

    # Orient the profile correctly at the start of the path.
    # The first segment of the path defines the direction.
    path_start_pt = path_points.first
    path_end_pt = path_points[1]
    path_vector = path_end_pt - path_start_pt
    
    # Default orientation: profile in XZ plane, normal along Y.
    # If path is along Y, this is correct. If path is along X, it needs rotation.
    # Our paths for flights are along Y. Landing segments can be along X or Y.
    # For now, let's assume the path starts along Y.
    
    # Transform the profile to the start of the path
    tr_move = Geom::Transformation.translation(path_start_pt)
    temp_face.transform!(tr_move)
    
    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if temp_face.valid? && path_edges.count > 0
      temp_face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile or path invalid."
      handrail_group.erase!
      return nil
    end
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Define the stepped bottom edge of the skirting (where it meets the stairs)
    # The first point is at the front-top of the first tread (or ground level if starting from 0)
    # For step `i` (0-indexed), tread top is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # For point *before* the first riser (i=0): (x_side, flight_start_y, flight_start_z)
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    (0...num_steps).each do |i|
      # Point at the base of the current riser (Y = previous tread front, Z = current tread top)
      y_tread_front = flight_start_y + (i * TREAD_DEPTH * direction_y)
      z_riser_base = flight_start_z + (i * RISER_HEIGHT)
      profile_pts << Geom::Point3d.new(x_side, y_tread_front, z_riser_base)
      
      # Point at the top of the current riser (Y = current tread front, Z = next tread top)
      z_riser_top = flight_start_z + ((i+1) * RISER_HEIGHT)
      profile_pts << Geom::Point3d.new(x_side, y_tread_front, z_riser_top)
    end
    
    # Add point at the top of the last riser (level with landing base)
    final_y_stepped = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    final_z_stepped = flight_start_z + NUM_STEPS_PER_FLIGHT * RISER_HEIGHT
    profile_pts << Geom::Point3d.new(x_side, final_y_stepped, final_z_stepped)

    # 2. Define the straight top edge of the skirting
    # This line runs parallel to the "line of the step nosings", offset upwards.
    # Nosing line start: (Y=flight_start_y, Z=flight_start_z + RISER_HEIGHT) -- this is the front-top of the 1st step
    # Nosing line end: (Y=final_y_stepped, Z=flight_start_z + (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT)
    
    top_edge_start_y = flight_start_y
    top_edge_start_z = flight_start_z + RISER_HEIGHT + SKIRTING_HEIGHT_ABOVE_NOSING

    top_edge_end_y = final_y_stepped
    top_edge_end_z = final_z_stepped + RISER_HEIGHT + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start
    profile_pts << Geom::Point3d.new(x_side, top_edge_end_y, top_edge_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_start_y, top_edge_start_z)
    
    # The loop is closed by add_face connecting the last point to the first.
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      face.pushpull(extrusion_vector) # Use vector directly
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path
    outer_handrail_path = []
    # First Flight Outer
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    # Start of landing segment is end of first flight path.
    # End of landing segment aligns with start of second flight path.
    landing_handrail_outer_y_level = outer_handrail_path.last.y # Y position remains constant across landing
    landing_handrail_outer_z_level = outer_handrail_path.last.z # Z position remains constant across landing
    
    # Point at the far X-end of the landing, aligned with outer edge of second flight.
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, landing_handrail_outer_y_level, landing_handrail_outer_z_level)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    # Skip first point of flight2 path to avoid duplication as it's covered by the landing segment.
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail")

    # Inner Handrail Path (More complex due to U-turn around the gap)
    inner_handrail_path = []
    # First Flight Inner
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    # Landing Inner U-Turn Path
    # This path defines the cornering of the inner handrail.
    # P1: End of first flight inner rail (already in inner_handrail_path)
    # P2: Straight segment along Y to the inner-front corner of the gap.
    # P3: Straight segment along X across the gap.
    # P4: Straight segment along Y to connect to the second flight's inner rail.
    
    # Common Z level for the landing handrails
    landing_rail_z = inner_handrail_path.last.z

    # Y-coordinate of the 'front' inner edge of the gap (where flight 1 ends)
    y_gap_front = landing_y_start # Same as flight1_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH

    # Y-coordinate of the 'back' inner edge of the gap (where flight 2 starts receding)
    y_gap_back = landing_y_end # Same as flight2_start_y

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    # The Y position for the turn is `landing_y_end` offset by `HANDRAIL_OFFSET_FROM_EDGE` (from inner edge of landing/gap).
    # Since `landing_y_end` is the 'back' edge of the full landing, the offset needs to be from that edge.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    # The X position is `flight2_x_offset` (start of second flight) offset inwards.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 3: Moves along Y to connect to the start of the second flight's inner handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_front + (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)
    
    # Second Flight Inner (Skip first point to avoid duplication)
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # --- Generate Skirtings ---
    skirting_color = "DarkGrey" # Could be a different material

    # First Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight1_start_x + STAIR_WIDTH
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight1_start_x (which is 0)
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Landing Gap Left Skirting (along X=STAIR_WIDTH, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Gap_Left_Skirting" }, skirting_color)

    # Landing Gap Right Skirting (along X=STAIR_WIDTH+GAP_WIDTH_X, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Gap_Right_Skirting" }, skirting_color)


    # Second Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight2_x_offset + STAIR_WIDTH
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight2_x_offset
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
#<NoMethodError: undefined method `transform!' for #<Sketchup::Face:0x0000000027d18e28>>
(eval):136:in `create_handrail'
(eval):314:in `generate_stairs'
(eval):460:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The Z of the nosing line for step `i` is `flight_start_z + (i+1) * RISER_HEIGHT`.
    # The handrail's Z is relative to this nosing line.

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Corrected Z calculation: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    temp_face = group_entities.add_face(profile_points_relative)
    unless temp_face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path
    tr_move = Geom::Transformation.translation(path_points.first)
    temp_face.transform!(tr_move)
    
    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      temp_face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe
    temp_face.erase! if temp_face.valid?
    
    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      face.pushpull(extrusion_vector) # Use vector directly
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path
    outer_handrail_path = []
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    landing_handrail_outer_y_level = outer_handrail_path.last.y 
    landing_handrail_outer_z_level = outer_handrail_path.last.z 
    
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, landing_handrail_outer_y_level, landing_handrail_outer_z_level)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail")

    # Inner Handrail Path (More complex due to U-turn around the gap)
    inner_handrail_path = []
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    # Common Z level for the landing handrails (taken from the end of the first flight's inner rail)
    landing_rail_z = inner_handrail_path.last.z

    # Y-coordinate of the 'front' inner edge of the gap (where flight 1 ends)
    y_gap_front = landing_y_start # Same as flight1_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH

    # Y-coordinate of the 'back' inner edge of the gap (where flight 2 starts receding)
    y_gap_back = landing_y_end # Same as flight2_start_y

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 3: Moves along Y to connect to the start of the second flight's inner handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_front + (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)
    
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail")
    
    # Apply colors
    assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }.material = Sketchup.active_model.materials.add("Wood_Handrail").color = Sketchup::Color.new(139, 69, 19)
    assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }.material = Sketchup.active_model.materials.add("Wood_Handrail").color = Sketchup::Color.new(139, 69, 19)


    # --- Generate Skirtings ---
    skirting_color = "DarkGrey" # Could be a different material
    
    # First Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight1_start_x + STAIR_WIDTH
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight1_start_x (which is 0)
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Landing Gap Left Skirting (along X=STAIR_WIDTH, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Gap_Left_Skirting" }, skirting_color)

    # Landing Gap Right Skirting (along X=STAIR_WIDTH+GAP_WIDTH_X, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Gap_Right_Skirting" }, skirting_color)


    # Second Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight2_x_offset + STAIR_WIDTH
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight2_x_offset
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
#<NoMethodError: undefined method `transform!' for #<Sketchup::Face:0x000000002dbc37c0>>
(eval):126:in `create_handrail'
(eval):306:in `generate_stairs'
(eval):442:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The Z of the nosing line for step `i` is `flight_start_z + (i+1) * RISER_HEIGHT`.
    # The handrail's Z is relative to this nosing line.

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Corrected Z calculation: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  # Added color_name parameter
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    temp_face = group_entities.add_face(profile_points_relative)
    unless temp_face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path
    tr_move = Geom::Transformation.translation(path_points.first)
    temp_face.transform!(tr_move)
    
    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      temp_face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe
    temp_face.erase! if temp_face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  # Added color_name parameter
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      face.pushpull(extrusion_vector) # Use vector directly
      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path
    outer_handrail_path = []
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    landing_handrail_outer_y_level = outer_handrail_path.last.y 
    landing_handrail_outer_z_level = outer_handrail_path.last.z 
    
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, landing_handrail_outer_y_level, landing_handrail_outer_z_level)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    # Pass color name to create_handrail
    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # Inner Handrail Path (More complex due to U-turn around the gap)
    inner_handrail_path = []
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    # Common Z level for the landing handrails (taken from the end of the first flight's inner rail)
    landing_rail_z = inner_handrail_path.last.z

    # Y-coordinate of the 'front' inner edge of the gap (where flight 1 ends)
    y_gap_front = landing_y_start # Same as flight1_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH

    # Y-coordinate of the 'back' inner edge of the gap (where flight 2 starts receding)
    y_gap_back = landing_y_end # Same as flight2_start_y

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 3: Moves along Y to connect to the start of the second flight's inner handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_front + (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)
    
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    # Pass color name to create_handrail
    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey" # Could be a different material
    
    # First Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight1_start_x + STAIR_WIDTH
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight1_start_x (which is 0)
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting (along X=STAIR_WIDTH, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting (along X=STAIR_WIDTH+GAP_WIDTH_X, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight2_x_offset + STAIR_WIDTH
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight2_x_offset
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
#<NoMethodError: undefined method `transform!' for #<Sketchup::Face:0x00000000285d1268>>
(eval):130:in `create_handrail'
(eval):317:in `generate_stairs'
(eval):440:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The Z of the nosing line for step `i` is `flight_start_z + (i+1) * RISER_HEIGHT`.
    # The handrail's Z is relative to this nosing line.

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Corrected Z calculation: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  # Added color_name parameter
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges) # Corrected line

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  # Added color_name parameter
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      face.pushpull(extrusion_vector) # Use vector directly
      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path
    outer_handrail_path = []
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    
    # Landing Outer (Extends from end of first flight outer handrail, straight across X)
    landing_handrail_outer_y_level = outer_handrail_path.last.y 
    landing_handrail_outer_z_level = outer_handrail_path.last.z 
    
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, landing_handrail_outer_y_level, landing_handrail_outer_z_level)

    # Second Flight Outer (Starts from landing outer handrail, continues receding in Y)
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    # Pass color name to create_handrail
    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # Inner Handrail Path (More complex due to U-turn around the gap)
    inner_handrail_path = []
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    # Common Z level for the landing handrails (taken from the end of the first flight's inner rail)
    landing_rail_z = inner_handrail_path.last.z

    # Y-coordinate of the 'front' inner edge of the gap (where flight 1 ends)
    y_gap_front = landing_y_start # Same as flight1_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH

    # Y-coordinate of the 'back' inner edge of the gap (where flight 2 starts receding)
    y_gap_back = landing_y_end # Same as flight2_start_y

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_back - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)

    # Inner rail segment 3: Moves along Y to connect to the start of the second flight's inner handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            y_gap_front + (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2), 
                                            landing_rail_z)
    
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    # Pass color name to create_handrail
    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey" # Could be a different material
    
    # First Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight1_start_x + STAIR_WIDTH
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight1_start_x (which is 0)
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting (along X=STAIR_WIDTH, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting (along X=STAIR_WIDTH+GAP_WIDTH_X, between Y=landing_y_start and Y=landing_y_end)
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    # x_side is at the outer edge of the flight: flight2_x_offset + STAIR_WIDTH
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    # x_side is at the inner edge of the flight: flight2_x_offset
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
#<TypeError: can't convert Geom::Vector3d into Float>
(eval):213:in `pushpull'
(eval):213:in `create_skirting'
(eval):360:in `generate_stairs'
(eval):440:in `<main>'
SketchUp:in `eval'
=> nil
# ============================
# U-SHAPED HANDRAIL GENERATOR
# Creates a clean, continuous handrail following a U-shaped stair path.
# ============================

model = Sketchup.active_model
entities = model.active_entities
model.start_operation("U-Shaped Handrail", true)

# ----------------------------
# BASIC PARAMETERS
# ----------------------------
riser_count = 11
tread_depth = 0.30.m
riser_height = 0.17.m

flight_width = 1.00.m
handrail_offset = 0.05.m     # horizontal offset from stair edge
handrail_height = 0.90.m     # vertical height above each tread
handrail_radius = 0.025.m    # circular handrail radius

# ----------------------------
# GEOMETRY BASE
# ----------------------------
flight_height = riser_count * riser_height
flight_length = riser_count * tread_depth

# Coordinates:
# First flight goes forward.
# Landing island.
# Second flight goes backward (parallel).
#
# You can rotate 180 degrees if you want mirrored orientation.

p1 = Geom::Point3d.new(0, 0, 0)
p2 = Geom::Point3d.new(0, flight_length, flight_height)
landing_length = flight_width
p3 = Geom::Point3d.new(0, flight_length + landing_length, flight_height)
p4 = Geom::Point3d.new(0, flight_length + landing_length + flight_length, 0)

# ----------------------------
# HANDRAIL PATH
# ----------------------------
# Offset outward along X-axis for handrail.
ox = handrail_offset
hz = handrail_height

path = []
path << Geom::Point3d.new(ox, p1.y, hz)
path << Geom::Point3d.new(ox, p2.y, hz)
path << Geom::Point3d.new(ox, p3.y, hz)
path << Geom::Point3d.new(ox, p4.y, hz)

edges = []
(path.length - 1).times do |i|
  edges << entities.add_line(path[i], path[i+1])
end

# ----------------------------
# CREATE HANDRAIL PROFILE
# ----------------------------
profile_group = entities.add_group
pg = profile_group.entities

# Circle perpendicular to path first segment
vec = edges.first.line[1]
normal = vec * -1

circle = pg.add_circle(path[0], normal, handrail_radius, 24)
profile_face = pg.add_face(circle)
profile_face.reverse! unless profile_face.normal.samedirection?(normal)

# ----------------------------
# FOLLOW ME
# ----------------------------
profile_face.followme(edges)

# Delete profile group
profile_group.erase!

# Group entire handrail
handrail_group = entities.add_group
edges.each { |e| handrail_group.entities.add_instance(e) rescue nil }

# Actually group entire geometry by collecting all new solids
# (safer method)
all = entities.select { |e| e.is_a?(Sketchup::Face) || e.is_a?(Sketchup::Edge) }
handrail_group.entities.add_entities(all)

model.commit_operation

#<ArgumentError: Cannot convert argument to Geom::Vector3d>
(eval):67:in `*'
(eval):67:in `<main>'
SketchUp:in `eval'
=> nil
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The Z of the nosing line for step `i` is `flight_start_z + (i+1) * RISER_HEIGHT`.
    # The handrail's Z is relative to this nosing line.

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Corrected Z calculation: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  # Added color_name parameter
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges)

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  # Added color_name parameter
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      # FIX: pushpull expects a Float, not a Vector3d.
      # Calculate the signed distance by projecting the extrusion vector onto the face normal.
      pushpull_distance = extrusion_vector.dot(face.normal)
      
      face.pushpull(pushpull_distance) # Pushpull with the calculated signed distance

      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path (Correct as identified, no changes needed here)
    outer_handrail_path = []
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    
    handrail_landing_z = outer_handrail_path.last.z

    # Landing segment (L-shape for outer handrail)
    # Point 1: Move horizontally in X to the other side of the gap, same Y as end of F1
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, outer_handrail_path.last.y, handrail_landing_z)
    
    # Point 2: Move horizontally in Y along the landing depth, same X as start of F2
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, flight2_start_y, handrail_landing_z)

    # Points for Second Flight (slicing [1..-1] to avoid duplicate of previous point)
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # Inner Handrail Path (Corrected to fix jaggedness)
    inner_handrail_path = []
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    landing_rail_z = inner_handrail_path.last.z

    turn_offset = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            landing_y_end - turn_offset, 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end - turn_offset, 
                                            landing_rail_z)

    # FIX: Add an explicit point at the start of the second flight's handrail before concatenating.
    # This ensures a straight segment instead of a diagonal one.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end, # Y-coordinate matches where F2 handrail segment starts
                                            landing_rail_z)
    
    # Concatenate the rest of the second flight points, skipping the first one (index 0)
    # because it's now explicitly added above.
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey"
    
    # First Flight Outer Skirting
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
Skirting 'First_Flight_Outer_Skirting' created successfully.
Skirting 'First_Flight_Inner_Skirting' created successfully.
Skirting 'Landing_Front_Skirting' created successfully.
Skirting 'Landing_Back_Skirting' created successfully.
Skirting 'Landing_Outer_Skirting' created successfully.
Skirting 'Landing_Gap_Left_Skirting' created successfully.
Skirting 'Landing_Gap_Right_Skirting' created successfully.
Skirting 'Second_Flight_Outer_Skirting' created successfully.
Skirting 'Second_Flight_Inner_Skirting' created successfully.
=> #<Sketchup::View:0x000000001dac01d0>
finished reading language file
finished reading language file
tb_mode,single
tb_Settingout,true
tb_Draw,true
tb_Edit,true
tb_Array,true
tb_Wall,true
tb_Staircase,true
tb_Win,true
tb_Roof,true
tb_Site,true
tb_Structure,true
point_on_face,true
divide,true
align,true
perpendicular_line,true
fonplane,true
bestface,true
extrude1,true
extrude2,true
move_vertex,true
fillet,true
chamfer,true
extend,true
offset_edge,true
hline_faces,true
slopeedges,true
linear_array,true
rect_array,true
polar_array,true
path_array,true
wallsctrl,true
opening,true
hgroove,true
escalator,true
wframe,true
dframe,true
paneldivide,true
screen1,true
hlouvres,true
vlouvres,true
joists,true
roof1,true
hiproof,true
revsurf,true
mdeck,true
stairsctrl,true
profiles_on_plane,true
cutfill,true
siteb,true
fndctrl,true
columnctrl,true
contour,true
setlayer,true
mergelayer,true
framesel,true
scale,true
center1,true
ptsinfo,true
extrude3,true
profiles3d,true
extrude0,true
loading 1001bit pro menu >> true
loading C:/Users/Administrator/AppData/Roaming/SketchUp/SketchUp 2025/SketchUp/Plugins/1001bit_pro/stairsctrl >> true
finished reading language file
setting dialog size
loading C:/Users/Administrator/AppData/Roaming/SketchUp/SketchUp 2025/SketchUp/Plugins/1001bit_pro/staircase2 >> true
finished reading language file
setting dialog size
finished reading preset file: C:/Users/Administrator/AppData/Roaming/SketchUp/SketchUp 2025/SketchUp/Plugins/1001bit_pro/preset/staircase2.txt
start creating options
total entry=["custom setting 1"]
adding options custom setting 1>> 1000.0mm/150.0mm/300.0mm/100.0mm/10/10/50.0mm/1000.0mm
point stage 0 --> (8831.127515 mm, 470.52406 mm, 0 mm)
point stage 1 --> (8794.897332 mm, 2711.111995 mm, 0 mm)
tilt= 26.56505117707799
lwoff=0.9294014862196445
voff=4.40170861712557
upoff=12.74042510826689
model = Sketchup.active_model
entities = model.active_entities
model.start_operation("U-Shaped Handrail", true)

# PARAMETERS
riser_count = 11
tread_depth = 0.30.m
riser_height = 0.17.m
flight_width = 1.00.m

handrail_offset = 0.05.m
handrail_height = 0.90.m
handrail_radius = 0.025.m

flight_height = riser_count * riser_height
flight_length = riser_count * tread_depth
landing_length = flight_width

# MAIN PATH POINTS (U SHAPE)
p1 = Geom::Point3d.new(handrail_offset, 0, handrail_height)
p2 = Geom::Point3d.new(handrail_offset, flight_length, flight_height + handrail_height - flight_height)
p3 = Geom::Point3d.new(handrail_offset, flight_length + landing_length, handrail_height)
p4 = Geom::Point3d.new(handrail_offset, flight_length + landing_length + flight_length, handrail_height - flight_height)

path_points = [p1, p2, p3, p4]

# CREATE PATH LINES
path_edges = []
(0..2).each do |i|
  path_edges << entities.add_line(path_points[i], path_points[i+1])
end

# CREATE A PROFILE CIRCLE
profile_group = entities.add_group
pg = profile_group.entities

# Stable, fixed perpendicular vector (X-axis)
normal = Geom::Vector3d.new(1, 0, 0)

circle = pg.add_circle(path_points.first, normal, handrail_radius, 24)
circle_face = pg.add_face(circle)
circle_face.reverse! if circle_face.normal.dot(normal) < 0

# FOLLOW ME SWEEP
circle_face.followme(path_edges)

# Delete the profile
profile_group.erase!

model.commit_operation

=> true
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  # This generates points at nosing height + handrail height.
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []

    (0..num_steps).each do |i|
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Z-coordinate: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      # For i=0, this is the first step (riser_height + handrail_height).
      # For i=num_steps, this is the landing level (num_steps+1 * riser_height + handrail_height).
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges)

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      # FIX: pushpull expects a Float, not a Vector3d.
      # Calculate the signed distance by projecting the extrusion vector onto the face normal.
      pushpull_distance = extrusion_vector.dot(face.normal)
      
      face.pushpull(pushpull_distance) # Pushpull with the calculated signed distance

      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Common Z level for handrails at landing height
    handrail_landing_z = landing_z_level + HANDRAIL_HEIGHT_FROM_TREAD

    # --- Outer Handrail Path ---
    outer_handrail_path = []
    # Add a starting point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment (excluding first point which is ground, and last point which is landing level)
    generated_f1_outer_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1)
    outer_handrail_path.concat(generated_f1_outer_points)
    
    # 2. Landing Segment (L-shape)
    # The last point added is the end of F1 handrail at landing Y_start and handrail_landing_z.
    # Move horizontally in X at the Y-level of the end of F1
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f1_outer_points.last.y, handrail_landing_z)
    # Move horizontally in Y to the Y-level of the start of F2
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, flight2_start_y, handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point which is the start of F2 path)
    generated_f2_outer_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)
    outer_handrail_path.concat(generated_f2_outer_points[1..-1])

    # Add an ending point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f2_outer_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # --- Inner Handrail Path (Corrected for smooth U-turn and ground level extensions) ---
    inner_handrail_path = []
    # Add a starting point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment
    generated_f1_inner_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1)
    inner_handrail_path.concat(generated_f1_inner_points)
    
    # 2. Landing U-Turn Segments
    # Offset applied from the true Y-edges of the landing to create the U-turn
    inner_turn_offset_y = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2
    
    # First Y-segment: Move along Y towards the back of the landing/gap (from F1 end to back corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            landing_y_end - inner_turn_offset_y, # Y-coord for back-turn
                                            handrail_landing_z)

    # X-segment: Move along X across the gap (at the back-turn Y-level)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end - inner_turn_offset_y, 
                                            handrail_landing_z)

    # Second Y-segment: Move along Y back towards the front of the landing/gap (from cross-gap to front corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_start + inner_turn_offset_y, # Y-coord for front-turn
                                            handrail_landing_z)
    
    # Connecting segment: Move along Y to perfectly align with the logical starting point of the Second Flight handrail
    # This point ensures a smooth vertical transition into the angled flight.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end, # Y-coordinate matches where F2 handrail segment logically starts
                                            handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point)
    generated_f2_inner_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)
    inner_handrail_path.concat(generated_f2_inner_points[1..-1])

    # Add an ending point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, generated_f2_inner_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey"
    
    # First Flight Outer Skirting
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
Skirting 'First_Flight_Outer_Skirting' created successfully.
Skirting 'First_Flight_Inner_Skirting' created successfully.
Skirting 'Landing_Front_Skirting' created successfully.
Skirting 'Landing_Back_Skirting' created successfully.
Skirting 'Landing_Outer_Skirting' created successfully.
Skirting 'Landing_Gap_Left_Skirting' created successfully.
Skirting 'Landing_Gap_Right_Skirting' created successfully.
Skirting 'Second_Flight_Outer_Skirting' created successfully.
Skirting 'Second_Flight_Inner_Skirting' created successfully.
=> #<Sketchup::View:0x000000001dac01d0>
loading C:/Users/Administrator/AppData/Roaming/SketchUp/SketchUp 2025/SketchUp/Plugins/1001bit_pro/stairsctrl >> false
finished reading language file
setting dialog size
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  # This generates points at nosing height + handrail height.
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []

    (0..num_steps).each do |i|
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Z-coordinate: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      # For i=0, this is the first step (riser_height + handrail_height).
      # For i=num_steps, this is the landing level (num_steps+1 * riser_height + handrail_height).
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges)

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      # FIX: pushpull expects a Float, not a Vector3d.
      # Calculate the signed distance by projecting the extrusion vector onto the face normal.
      pushpull_distance = extrusion_vector.dot(face.normal)
      
      face.pushpull(pushpull_distance) # Pushpull with the calculated signed distance

      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Common Z level for handrails at landing height
    handrail_landing_z = landing_z_level + HANDRAIL_HEIGHT_FROM_TREAD

    # --- Outer Handrail Path ---
    outer_handrail_path = []
    # Add a starting point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment (excluding first point which is ground, and last point which is landing level)
    generated_f1_outer_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1)
    outer_handrail_path.concat(generated_f1_outer_points)
    
    # 2. Landing Segment (L-shape)
    # The last point added is the end of F1 handrail at landing Y_start and handrail_landing_z.
    # Move horizontally in X at the Y-level of the end of F1
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f1_outer_points.last.y, handrail_landing_z)
    # Move horizontally in Y to the Y-level of the start of F2
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, flight2_start_y, handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point which is the start of F2 path)
    generated_f2_outer_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)
    outer_handrail_path.concat(generated_f2_outer_points[1..-1])

    # Add an ending point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f2_outer_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # --- Inner Handrail Path (Corrected for smooth U-turn and ground level extensions) ---
    inner_handrail_path = []
    # Add a starting point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment
    generated_f1_inner_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1)
    inner_handrail_path.concat(generated_f1_inner_points)
    
    # 2. Landing U-Turn Segments
    # Offset applied from the true Y-edges of the landing to create the U-turn
    inner_turn_offset_y = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2
    
    # First Y-segment: Move along Y towards the back of the landing/gap (from F1 end to back corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            landing_y_end - inner_turn_offset_y, # Y-coord for back-turn
                                            handrail_landing_z)

    # X-segment: Move along X across the gap (at the back-turn Y-level)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end - inner_turn_offset_y, 
                                            handrail_landing_z)

    # Second Y-segment: Move along Y back towards the front of the landing/gap (from cross-gap to front corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_start + inner_turn_offset_y, # Y-coord for front-turn
                                            handrail_landing_z)
    
    # Connecting segment: Move along Y to perfectly align with the logical starting point of the Second Flight handrail
    # This point ensures a smooth vertical transition into the angled flight.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end, # Y-coordinate matches where F2 handrail segment logically starts
                                            handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point)
    generated_f2_inner_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)
    inner_handrail_path.concat(generated_f2_inner_points[1..-1])

    # Add an ending point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, generated_f2_inner_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey"
    
    # First Flight Outer Skirting
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
Skirting 'First_Flight_Outer_Skirting' created successfully.
Skirting 'First_Flight_Inner_Skirting' created successfully.
Skirting 'Landing_Front_Skirting' created successfully.
Skirting 'Landing_Back_Skirting' created successfully.
Skirting 'Landing_Outer_Skirting' created successfully.
Skirting 'Landing_Gap_Left_Skirting' created successfully.
Skirting 'Landing_Gap_Right_Skirting' created successfully.
Skirting 'Second_Flight_Outer_Skirting' created successfully.
Skirting 'Second_Flight_Inner_Skirting' created successfully.
=> #<Sketchup::View:0x000000001dac01d0>
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  # This generates points at nosing height + handrail height.
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []

    (0..num_steps).each do |i|
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Z-coordinate: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      # For i=0, this is the first step (riser_height + handrail_height).
      # For i=num_steps, this is the landing level (num_steps+1 * riser_height + handrail_height).
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges)

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      # FIX: pushpull expects a Float, not a Vector3d.
      # Calculate the signed distance by projecting the extrusion vector onto the face normal.
      pushpull_distance = extrusion_vector.dot(face.normal)
      
      face.pushpull(pushpull_distance) # Pushpull with the calculated signed distance

      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Common Z level for handrails at landing height
    handrail_landing_z = landing_z_level + HANDRAIL_HEIGHT_FROM_TREAD

    # --- Outer Handrail Path ---
    outer_handrail_path = []
    # Add a starting point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment (excluding first point which is ground, and last point which is landing level)
    generated_f1_outer_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1)
    outer_handrail_path.concat(generated_f1_outer_points)
    
    # 2. Landing Segment (L-shape)
    # The last point added is the end of F1 handrail at landing Y_start and handrail_landing_z.
    # Move horizontally in X at the Y-level of the end of F1
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f1_outer_points.last.y, handrail_landing_z)
    # Move horizontally in Y to the Y-level of the start of F2
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, flight2_start_y, handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point which is the start of F2 path)
    generated_f2_outer_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)
    outer_handrail_path.concat(generated_f2_outer_points[1..-1])

    # Add an ending point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f2_outer_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # --- Inner Handrail Path (Corrected for smooth U-turn and ground level extensions) ---
    inner_handrail_path = []
    # Add a starting point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment
    generated_f1_inner_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1)
    inner_handrail_path.concat(generated_f1_inner_points)
    
    # 2. Landing U-Turn Segments
    # Offset applied from the true Y-edges of the landing to create the U-turn
    inner_turn_offset_y = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2
    
    # First Y-segment: Move along Y towards the back of the landing/gap (from F1 end to back corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            landing_y_end - inner_turn_offset_y, # Y-coord for back-turn
                                            handrail_landing_z)

    # X-segment: Move along X across the gap (at the back-turn Y-level)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end - inner_turn_offset_y, 
                                            handrail_landing_z)

    # Second Y-segment: Move along Y back towards the front of the landing/gap (from cross-gap to front corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_start + inner_turn_offset_y, # Y-coord for front-turn
                                            handrail_landing_z)
    
    # Connecting segment: Move along Y to perfectly align with the logical starting point of the Second Flight handrail
    # This point ensures a smooth vertical transition into the angled flight.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end, # Y-coordinate matches where F2 handrail segment logically starts
                                            handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point)
    generated_f2_inner_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)
    inner_handrail_path.concat(generated_f2_inner_points[1..-1])

    # Add an ending point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, generated_f2_inner_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey"
    
    # First Flight Outer Skirting
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
Skirting 'First_Flight_Outer_Skirting' created successfully.
Skirting 'First_Flight_Inner_Skirting' created successfully.
Skirting 'Landing_Front_Skirting' created successfully.
Skirting 'Landing_Back_Skirting' created successfully.
Skirting 'Landing_Outer_Skirting' created successfully.
Skirting 'Landing_Gap_Left_Skirting' created successfully.
Skirting 'Landing_Gap_Right_Skirting' created successfully.
Skirting 'Second_Flight_Outer_Skirting' created successfully.
Skirting 'Second_Flight_Inner_Skirting' created successfully.
=> #<Sketchup::View:0x000000001dac01d0>
model = Sketchup.active_model
entities = model.active_entities
model.start_operation("U-Shaped Handrail", true)

# PARAMETERS
riser_count = 11
tread_depth = 0.30.m
riser_height = 0.17.m
flight_width = 1.00.m

handrail_offset = 0.05.m
handrail_height = 0.90.m
handrail_radius = 0.025.m

flight_height = riser_count * riser_height
flight_length = riser_count * tread_depth
landing_length = flight_width

# MAIN PATH POINTS (U SHAPE)
p1 = Geom::Point3d.new(handrail_offset, 0, handrail_height)
p2 = Geom::Point3d.new(handrail_offset, flight_length, flight_height + handrail_height - flight_height)
p3 = Geom::Point3d.new(handrail_offset, flight_length + landing_length, handrail_height)
p4 = Geom::Point3d.new(handrail_offset, flight_length + landing_length + flight_length, handrail_height - flight_height)

path_points = [p1, p2, p3, p4]

# CREATE PATH LINES
path_edges = []
(0..2).each do |i|
  path_edges << entities.add_line(path_points[i], path_points[i+1])
end

# CREATE A PROFILE CIRCLE
profile_group = entities.add_group
pg = profile_group.entities

# Stable, fixed perpendicular vector (X-axis)
normal = Geom::Vector3d.new(1, 0, 0)

circle = pg.add_circle(path_points.first, normal, handrail_radius, 24)
circle_face = pg.add_face(circle)
circle_face.reverse! if circle_face.normal.dot(normal) < 0

# FOLLOW ME SWEEP
circle_face.followme(path_edges)

# Delete the profile
profile_group.erase!

model.commit_operation

=> true
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  # This generates points at nosing height + handrail height.
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []

    (0..num_steps).each do |i|
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Z-coordinate: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      # For i=0, this is the first step (riser_height + handrail_height).
      # For i=num_steps, this is the landing level (num_steps+1 * riser_height + handrail_height).
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges)

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      # FIX: pushpull expects a Float, not a Vector3d.
      # Calculate the signed distance by projecting the extrusion vector onto the face normal.
      pushpull_distance = extrusion_vector.dot(face.normal)
      
      face.pushpull(pushpull_distance) # Pushpull with the calculated signed distance

      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Common Z level for handrails at landing height
    handrail_landing_z = landing_z_level + HANDRAIL_HEIGHT_FROM_TREAD

    # --- Outer Handrail Path ---
    outer_handrail_path = []
    # Add a starting point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment (excluding first point which is ground, and last point which is landing level)
    generated_f1_outer_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1)
    outer_handrail_path.concat(generated_f1_outer_points)
    
    # 2. Landing Segment (L-shape)
    # The last point added is the end of F1 handrail at landing Y_start and handrail_landing_z.
    # Move horizontally in X at the Y-level of the end of F1
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f1_outer_points.last.y, handrail_landing_z)
    # Move horizontally in Y to the Y-level of the start of F2
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, flight2_start_y, handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point which is the start of F2 path)
    generated_f2_outer_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)
    outer_handrail_path.concat(generated_f2_outer_points[1..-1])

    # Add an ending point at ground level for the handrail
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, generated_f2_outer_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # --- Inner Handrail Path (Corrected for smooth U-turn and ground level extensions) ---
    inner_handrail_path = []
    # Add a starting point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, flight1_start_y, flight1_start_z)

    # 1. First Flight Segment
    generated_f1_inner_points = generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1)
    inner_handrail_path.concat(generated_f1_inner_points)
    
    # 2. Landing U-Turn Segments
    # Offset applied from the true Y-edges of the landing to create the U-turn
    inner_turn_offset_y = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2
    
    # First Y-segment: Move along Y towards the back of the landing/gap (from F1 end to back corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            landing_y_end - inner_turn_offset_y, # Y-coord for back-turn
                                            handrail_landing_z)

    # X-segment: Move along X across the gap (at the back-turn Y-level)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end - inner_turn_offset_y, 
                                            handrail_landing_z)

    # Second Y-segment: Move along Y back towards the front of the landing/gap (from cross-gap to front corner of U)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_start + inner_turn_offset_y, # Y-coord for front-turn
                                            handrail_landing_z)
    
    # Connecting segment: Move along Y to perfectly align with the logical starting point of the Second Flight handrail
    # This point ensures a smooth vertical transition into the angled flight.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end, # Y-coordinate matches where F2 handrail segment logically starts
                                            handrail_landing_z)

    # 3. Second Flight Segment (slicing [1..-1] to avoid duplicate of previous point)
    generated_f2_inner_points = generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)
    inner_handrail_path.concat(generated_f2_inner_points[1..-1])

    # Add an ending point at ground level for the handrail
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, generated_f2_inner_points.last.y, flight2_start_z)

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey"
    
    # First Flight Outer Skirting
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
Skirting 'First_Flight_Outer_Skirting' created successfully.
Skirting 'First_Flight_Inner_Skirting' created successfully.
Skirting 'Landing_Front_Skirting' created successfully.
Skirting 'Landing_Back_Skirting' created successfully.
Skirting 'Landing_Outer_Skirting' created successfully.
Skirting 'Landing_Gap_Left_Skirting' created successfully.
Skirting 'Landing_Gap_Right_Skirting' created successfully.
Skirting 'Second_Flight_Outer_Skirting' created successfully.
Skirting 'Second_Flight_Inner_Skirting' created successfully.
=> #<Sketchup::View:0x000000001dac01d0>
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge (to handrail's nearest edge)

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above the line of the step nosings

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    return unless group # Ensure group is not nil

    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      when "DarkGrey" then material.color = Sketchup::Color.new(80, 80, 80)
      when "Wood_Handrail" then material.color = Sketchup::Color.new(139, 69, 19) # Specific wood for handrails
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `x_centerline_position` is the X-coordinate for the centerline of the handrail
  def self.generate_handrail_path_points(flight_start_x, flight_start_y, flight_start_z,
                                         num_steps, direction_y, x_centerline_position)
    path_points = []
    # The Z of the nosing line for step `i` is `flight_start_z + (i+1) * RISER_HEIGHT`.
    # The handrail's Z is relative to this nosing line.

    (0..num_steps).each do |i|
      # Y-coordinate for the front edge of step 'i' (which is the nosing line)
      # For i=0, this is the start of the first tread (y=0 for flight1, y=start_y for flight2)
      # For i=NUM_STEPS_PER_FLIGHT, this is the level of the landing
      
      current_y = flight_start_y + (i * TREAD_DEPTH * direction_y)
      
      # Corrected Z calculation: Nosing line Z + HANDRAIL_HEIGHT_FROM_TREAD
      current_z_nosing_level = flight_start_z + ((i + 1) * RISER_HEIGHT)
      current_z = current_z_nosing_level + HANDRAIL_HEIGHT_FROM_TREAD

      path_points << Geom::Point3d.new(x_centerline_position, current_y, current_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  # Added color_name parameter
  def self.create_handrail(entities_collection, path_points, name, color_name = nil)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # Ensure there are enough points for a path
    unless path_points.length >= 2
      puts "Warning: Handrail path for #{name} has less than 2 points. Skipping creation."
      handrail_group.erase!
      return nil
    end

    # Create the profile face for FollowMe directly in the group's entities.
    # The profile is a rectangle in the XZ plane, centered on the origin, then transformed.
    profile_points_relative = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2),
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2),
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)
    ]
    
    # Create an initial face at origin, then transform it
    face = group_entities.add_face(profile_points_relative)
    unless face.valid?
      puts "Warning: Initial profile face for handrail #{name} creation failed. Path: #{path_points.to_s}"
      handrail_group.erase!
      return nil
    end

    # Transform the profile to the start of the path using entities.transform_entities
    tr_move = Geom::Transformation.translation(path_points.first)
    group_entities.transform_entities(tr_move, face, *face.edges)

    # The path for FollowMe should be edges. Add a curve and get its edges.
    path_edges = group_entities.add_curve(path_points)
    
    if path_edges.count > 0
      face.followme(path_edges)
    else
      puts "Warning: FollowMe failed for handrail #{name}. Path edges could not be created."
      handrail_group.erase!
      return nil
    end
    
    # Ensure the original profile face is removed after FollowMe (it gets consumed by FollowMe, but good practice)
    face.erase! if face.valid?
    
    # Apply color after successful creation
    apply_color(handrail_group, color_name) if color_name

    puts "Handrail '#{name}' created successfully."
    handrail_group
  end
  
  # Helper to generate the profile points for a skirting on one side of a flight.
  # This function creates a closed polygon that outlines the skirting.
  # The skirting sits on the side of the stairs, with its bottom following the
  # top of treads and front of risers, and its top parallel to the nosing line.
  # `x_side` is the X-coordinate for this specific skirting plane.
  def self.generate_skirting_profile_points(x_side, flight_start_y, flight_start_z,
                                            num_steps, direction_y)
    profile_pts = []

    # 1. Start at the bottom-front corner of the first riser (ground level)
    # This point is at the X-plane of the skirting, at the Y-position of the front of the first step,
    # and at the Z-position of the ground (or flight_start_z).
    profile_pts << Geom::Point3d.new(x_side, flight_start_y, flight_start_z)

    # 2. Define the stepped bottom edge of the skirting, following risers and treads
    (0...num_steps).each do |i|
      # Y-coordinate for the front edge of the current tread/riser
      current_y_front_edge = flight_start_y + (i * TREAD_DEPTH * direction_y)
      # Y-coordinate for the back edge of the current tread/riser
      current_y_back_edge = flight_start_y + ((i + 1) * TREAD_DEPTH * direction_y)
      
      # Z-coordinate for the top of the current riser (also the top of the current tread)
      current_z_riser_top = flight_start_z + ((i + 1) * RISER_HEIGHT)

      # Go up the current riser (vertical segment) - from previous y_front_edge, to current z_riser_top
      profile_pts << Geom::Point3d.new(x_side, current_y_front_edge, current_z_riser_top)
      
      # Go along the top of the current tread (horizontal segment)
      profile_pts << Geom::Point3d.new(x_side, current_y_back_edge, current_z_riser_top)
    end
    
    # 3. Define the straight top edge of the skirting, parallel to the nosing line.
    # The 'line of the step nosings' for step 'i' is at Z = flight_start_z + (i+1)*RISER_HEIGHT
    # Its Y is flight_start_y + i*TREAD_DEPTH*direction_y.

    # Start point for the top edge of skirting (above the first step's nosing)
    top_edge_skirting_start_y = flight_start_y
    top_edge_skirting_start_z = (flight_start_z + RISER_HEIGHT) + SKIRTING_HEIGHT_ABOVE_NOSING

    # End point for the top edge of skirting (above the last step's nosing, before landing)
    top_edge_skirting_end_y = flight_start_y + NUM_STEPS_PER_FLIGHT * TREAD_DEPTH * direction_y
    top_edge_skirting_end_z = (flight_start_z + (NUM_STEPS_PER_FLIGHT * RISER_HEIGHT)) + SKIRTING_HEIGHT_ABOVE_NOSING

    # Add points for the top edge, going from end back to start to close the profile
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_end_y, top_edge_skirting_end_z)
    profile_pts << Geom::Point3d.new(x_side, top_edge_skirting_start_y, top_edge_skirting_start_z)
    
    profile_pts
  end

  # Helper to create a skirting by adding a face and pushpulling it
  # Added color_name parameter
  def self.create_skirting(entities_collection, profile_points, extrusion_vector, name, color_name = nil)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    # Add the points to form a face
    face = group_entities.add_face(profile_points)

    if face.valid?
      # FIX: pushpull expects a Float, not a Vector3d.
      # Calculate the signed distance by projecting the extrusion vector onto the face normal.
      pushpull_distance = extrusion_vector.dot(face.normal)
      
      face.pushpull(pushpull_distance) # Pushpull with the calculated signed distance

      # Apply color after successful creation
      apply_color(skirting_group, color_name) if color_name
      puts "Skirting '#{name}' created successfully."
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "Blue")
    
    # Coordinates for the first flight
    # The first step (i=0) has its top at 1*riser_height.
    # The first step's Y-range is 0 to 1*tread_depth.
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT # Top surface of landing
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "White")

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    flight2_start_y = landing_y_end # Starts from the far edge of the landing
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # Handrail centerline offsets from respective flight edges
    handrail_x_offset_outer_f1 = flight1_start_x + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f1 = flight1_start_x + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    handrail_x_offset_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_offset_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2
    
    # Outer Handrail Path (Correct as identified, no changes needed here)
    outer_handrail_path = []
    outer_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_outer_f1))
    
    handrail_landing_z = outer_handrail_path.last.z

    # Landing segment (L-shape for outer handrail)
    # Point 1: Move horizontally in X to the other side of the gap, same Y as end of F1
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, outer_handrail_path.last.y, handrail_landing_z)
    
    # Point 2: Move horizontally in Y along the landing depth, same X as start of F2
    outer_handrail_path << Geom::Point3d.new(handrail_x_offset_outer_f2, flight2_start_y, handrail_landing_z)

    # Points for Second Flight (slicing [1..-1] to avoid duplicate of previous point)
    outer_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_handrail_path, "Outer_Handrail", "Wood_Handrail")

    # Inner Handrail Path (Corrected to fix jaggedness)
    inner_handrail_path = []
    inner_handrail_path.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                          NUM_STEPS_PER_FLIGHT, 1, handrail_x_offset_inner_f1))
    
    landing_rail_z = inner_handrail_path.last.z

    turn_offset = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH/2

    # Inner rail segment 1: Moves along Y towards the 'back' of the landing (along the gap)
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f1, 
                                            landing_y_end - turn_offset, 
                                            landing_rail_z)

    # Inner rail segment 2: Moves along X across the gap
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end - turn_offset, 
                                            landing_rail_z)

    # FIX: Add an explicit point at the start of the second flight's handrail before concatenating.
    # This ensures a straight segment instead of a diagonal one.
    inner_handrail_path << Geom::Point3d.new(handrail_x_offset_inner_f2, 
                                            landing_y_end, # Y-coordinate matches where F2 handrail segment starts
                                            landing_rail_z)
    
    # Concatenate the rest of the second flight points, skipping the first one (index 0)
    # because it's now explicitly added above.
    inner_handrail_path.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                          NUM_STEPS_PER_FLIGHT, -1, handrail_x_offset_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_handrail_path, "Inner_Handrail", "Wood_Handrail")
    
    # --- Generate Skirtings ---
    skirting_color = "DarkGrey"
    
    # First Flight Outer Skirting
    skirting_profile_f1_outer = generate_skirting_profile_points(flight1_start_x + STAIR_WIDTH, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "First_Flight_Outer_Skirting", skirting_color)

    # First Flight Inner Skirting
    skirting_profile_f1_inner = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z, NUM_STEPS_PER_FLIGHT, 1)
    create_skirting(assembly_entities, skirting_profile_f1_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "First_Flight_Inner_Skirting", skirting_color)

    # Landing Skirtings (panels on top of the landing surface)
    land_skirt_z_bottom = landing_z_level
    land_skirt_z_top = landing_z_level + SKIRTING_HEIGHT_ABOVE_NOSING

    # Landing Front Skirting
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -SKIRTING_THICKNESS, 0), "Landing_Front_Skirting", skirting_color)

    # Landing Back Skirting
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_start, landing_y_end, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, SKIRTING_THICKNESS, 0), "Landing_Back_Skirting", skirting_color)

    # Landing Outer Skirting
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(landing_x_end, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(landing_x_end, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Outer_Skirting", skirting_color)
    
    # Landing Gap Left Skirting
    sk_land_gap_left_pts = [
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_left_pts, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Left_Skirting", skirting_color)

    # Landing Gap Right Skirting
    sk_land_gap_right_pts = [
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_bottom),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_end, land_skirt_z_top),
      Geom::Point3d.new(STAIR_WIDTH + GAP_WIDTH_X, landing_y_start, land_skirt_z_top)
    ]
    create_skirting(assembly_entities, sk_land_gap_right_pts, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Landing_Gap_Right_Skirting", skirting_color)


    # Second Flight Outer Skirting
    skirting_profile_f2_outer = generate_skirting_profile_points(flight2_x_offset + STAIR_WIDTH, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_outer, Geom::Vector3d.new(SKIRTING_THICKNESS, 0, 0), "Second_Flight_Outer_Skirting", skirting_color)

    # Second Flight Inner Skirting
    skirting_profile_f2_inner = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z, NUM_STEPS_PER_FLIGHT, -1)
    create_skirting(assembly_entities, skirting_profile_f2_inner, Geom::Vector3d.new(-SKIRTING_THICKNESS, 0, 0), "Second_Flight_Inner_Skirting", skirting_color)


    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
Handrail 'Outer_Handrail' created successfully.
Handrail 'Inner_Handrail' created successfully.
Skirting 'First_Flight_Outer_Skirting' created successfully.
Skirting 'First_Flight_Inner_Skirting' created successfully.
Skirting 'Landing_Front_Skirting' created successfully.
Skirting 'Landing_Back_Skirting' created successfully.
Skirting 'Landing_Outer_Skirting' created successfully.
Skirting 'Landing_Gap_Left_Skirting' created successfully.
Skirting 'Landing_Gap_Right_Skirting' created successfully.
Skirting 'Second_Flight_Outer_Skirting' created successfully.
Skirting 'Second_Flight_Inner_Skirting' created successfully.
=> #<Sketchup::View:0x000000001dac01d0>
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above step nosing line

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `handrail_x_pos_offset` is the X-coordinate for the centerline of the handrail
  # Path points will define the CENTER of the handrail's cross-section.
  def self.generate_handrail_path_points(flight_x_offset, flight_y_base, flight_z_base,
                                         num_steps, direction_y, handrail_x_pos_offset)
    path_points = []
    
    # Start point on the ground plane, at the front of the first riser.
    # Z for handrail center at this level: flight_z_base (ground) + HANDRAIL_HEIGHT_FROM_TREAD (to top) - (HANDRAIL_DEPTH / 2) (to center)
    path_points << Geom::Point3d.new(handrail_x_pos_offset, flight_y_base,
                                     flight_z_base + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2))

    # Points above the nosing of each subsequent step
    (0...num_steps).each do |i|
      # Y-coordinate at the nosing of step (i+1)
      step_nosing_y = flight_y_base + ((i + 1) * TREAD_DEPTH * direction_y)
      # Z-coordinate at the nosing of step (i+1)
      step_nosing_z = flight_z_base + (i + 1) * RISER_HEIGHT
      
      # Handrail center Z-coordinate above this nosing
      handrail_center_z = step_nosing_z + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)
      
      path_points << Geom::Point3d.new(handrail_x_pos_offset, step_nosing_y, handrail_center_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # 1. Create the path edges
    path_edges = group_entities.add_curve(path_points)
    unless path_edges && path_edges.length > 0 # A path needs at least one edge (two points)
      puts "Error: Invalid path for handrail #{name}. Not enough points: #{path_points.length} points."
      handrail_group.erase!
      return nil
    end

    # 2. Define the profile face's vertices directly in their correct, transformed positions.
    # The path_points define the center line of the handrail.
    # The profile face needs to be perpendicular to the first segment of the path.

    # Get the vector of the first segment of the path.
    v_path = (path_points[1] - path_points[0]).normalize
    
    # Create a transformation to align the profile at the start of the path.
    # v_path will be the local Y-axis (extrusion direction).
    # We need local X and Z axes perpendicular to v_path.
    # `v_path.axes` returns an array: [v_path, perpendicular_x, perpendicular_z] (arbitrary order for latter two).
    tr_profile_alignment = Geom::Transformation.axes(path_points.first, v_path.axes[1], v_path, v_path.axes[2])

    # Define the profile points relative to its own local origin (0,0,0) and axes.
    # The profile will be centered on path_points.first, and lie in the local XZ plane.
    local_pts = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-left
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-right
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2), # Top-right
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)  # Top-left
    ]
    
    # Transform these local points to their absolute positions in the model space.
    absolute_pts = local_pts.map { |pt| pt.transform(tr_profile_alignment) }

    # Create the profile face in the group's entities
    profile_face = group_entities.add_face(absolute_pts)

    if profile_face.valid?
      # Ensure the face normal points *away* from the path's direction for FollowMe to work reliably.
      # If `profile_face.normal.dot(v_path)` is positive, the face is pointing along the path, so reverse it.
      if profile_face.normal.dot(v_path) > 0.001 # Use a small tolerance for comparison
        profile_face.reverse!
      end
      
      # Now use followme
      profile_face.followme(path_edges)
      return handrail_group
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile face creation failed or is invalid."
      handrail_group.erase!
      return nil
    end
  end
  
  # Helper to generate profile points for a stepped skirting face.
  # This returns a closed loop of points representing the side profile of the skirting.
  def self.generate_skirting_profile_points(flight_start_x, flight_start_y, flight_start_z,
                                              num_steps, direction_y, is_inner)
    profile_points = []
    x_pos = is_inner ? flight_start_x : flight_start_x + STAIR_WIDTH
    
    # 1. Start at the bottom-front corner (ground level for this flight segment)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z)

    # 2. Go up vertically to the top-front corner (skirting height at ground level)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z + SKIRTING_HEIGHT_ABOVE_NOSING)

    # 3. Trace the top stepped edge of the skirting (above the nosings)
    (0...num_steps).each do |i|
      y_tread_nosing = flight_start_y + (i + 1) * TREAD_DEPTH * direction_y
      z_tread_nosing = flight_start_z + (i + 1) * RISER_HEIGHT
      profile_points << Geom::Point3d.new(x_pos, y_tread_nosing, z_tread_nosing + SKIRTING_HEIGHT_ABOVE_NOSING)
    end
    
    # 4. Now trace the bottom stepped edge, going from the end of the flight back to the start.
    # Start from the bottom-back of the last riser (where it meets the landing/next segment)
    # The last riser's base point will be at Z = (NUM_STEPS_PER_FLIGHT) * RISER_HEIGHT
    # And Y = (NUM_STEPS_PER_FLIGHT) * TREAD_DEPTH * direction_y

    # First point on the way back down (bottom of the last riser)
    y_last_riser_base = flight_start_y + num_steps * TREAD_DEPTH * direction_y
    z_last_riser_base = flight_start_z + num_steps * RISER_HEIGHT
    profile_points << Geom::Point3d.new(x_pos, y_last_riser_base, z_last_riser_base)
    
    (num_steps - 1).downto(0) do |i|
      # This is the point at the base of riser (i+1) from the top (or riser `i` from the ground, where `i` is current step index)
      y_riser_base = flight_start_y + (i * TREAD_DEPTH * direction_y)
      z_riser_base = flight_start_z + (i * RISER_HEIGHT)
      profile_points << Geom::Point3d.new(x_pos, y_riser_base, z_riser_base)
    end
    
    # The last point added by the loop for i=0 is (x_pos, flight_start_y, flight_start_z) which is our first point.
    # To ensure a clean closed loop for `add_face` (no duplicate start/end point), remove the last point if it matches the first.
    if profile_points.last == profile_points.first
      profile_points.pop
    end
    
    return profile_points
  end

  # Helper to create a skirting by push-pulling a profile face
  def self.create_skirting(entities_collection, profile_points, extrusion_dir_unit_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    face = group_entities.add_face(profile_points)

    if face.valid?
      # Determine the extrusion distance based on face normal relative to desired direction.
      # `extrusion_dir_unit_vector` defines the desired outward direction.
      # If face normal is generally aligned with `extrusion_dir_unit_vector`, pushpull by `SKIRTING_THICKNESS`.
      # Otherwise, pushpull by `-SKIRTING_THICKNESS`.
      if face.normal.dot(extrusion_dir_unit_vector).abs < 0.001
         puts "Warning: Skirting face normal is nearly perpendicular to extrusion vector for #{name}. Check points."
         skirting_group.erase!
         return nil
      elsif face.normal.dot(extrusion_dir_unit_vector) > 0 # Face normal points in the desired direction
        face.pushpull(SKIRTING_THICKNESS)
      else # Face normal points opposite to the desired direction
        face.pushpull(-SKIRTING_THICKNESS)
      end
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "White") # Matching the image: First flight is white
    
    # Coordinates for the first flight
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    # This flight starts at the landing's Z-level, is shifted in X, and recedes along the Y-axis.
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "Blue") # Matching the image: Second flight is blue

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    # The second flight starts precisely from the far edge of the landing, stepping backwards.
    flight2_start_y = landing_y_end
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent (bottom of landing)

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # The Z-level for handrails over the landing is constant.
    landing_handrail_z = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)

    # X-offsets for the center of the handrails
    handrail_x_outer_f1 = STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_inner_f1 = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2 
    handrail_x_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    # --- Outer Handrail Path ---
    outer_rail_points = []
    
    # Part A: First Flight Section (from ground to landing level)
    outer_rail_points.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                            NUM_STEPS_PER_FLIGHT, 1, handrail_x_outer_f1))
    
    # Part B: Outer Landing Horizontal Segment (across X, at Y=landing_y_start)
    # The last point from Part A is `(handrail_x_outer_f1, landing_y_start, landing_handrail_z)`
    outer_rail_points << Geom::Point3d.new(handrail_x_outer_f2, outer_rail_points.last.y, landing_handrail_z)
    
    # Part C: Outer Landing Turn Segment (along Y) - connecting to start of second flight.
    # From `(handrail_x_outer_f2, landing_y_start, landing_handrail_z)` to `(handrail_x_outer_f2, landing_y_end, landing_handrail_z)`
    outer_rail_points << Geom::Point3d.new(handrail_x_outer_f2, flight2_start_y, landing_handrail_z) # flight2_start_y is landing_y_end
    
    # Part D: Second Flight Section (from landing level down to ground)
    # The first point generated by `generate_handrail_path_points` for F2 is `(handrail_x_outer_f2, flight2_start_y, landing_handrail_z)`.
    # This is exactly the last point added in Part C, so we skip it to avoid duplication.
    outer_rail_points.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                            NUM_STEPS_PER_FLIGHT, -1, handrail_x_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_rail_points, "Outer_Handrail")

    # --- Inner Handrail Path ---
    inner_rail_points = []

    # Part A: First Flight Inner Section
    inner_rail_points.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                            NUM_STEPS_PER_FLIGHT, 1, handrail_x_inner_f1))
    
    # Part B: Inner Landing Turn (Y-segment)
    # From end of F1 rail `(handrail_x_inner_f1, inner_rail_points.last.y, landing_handrail_z)`
    # to the inner corner of the gap: `(handrail_x_inner_f1, landing_y_end - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2), landing_handrail_z)`
    # NOTE: Offset for the inner corner needs to be `(landing_depth_y - (offset_from_edge + half_width))` from the 'y_start' of the landing.
    inner_gap_y_pos = landing_y_end - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2)
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f1, inner_gap_y_pos, landing_handrail_z)

    # Part C: Inner Landing Horizontal Segment (across X - the gap itself)
    # Across the gap to align with F2 inner rail starting X
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f2, inner_gap_y_pos, landing_handrail_z)

    # Part D: Inner Landing Turn (Y-segment)
    # From the end of Part C to the starting Y of F2 inner rail (`flight2_start_y`)
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f2, flight2_start_y, landing_handrail_z)

    # Part E: Second Flight Inner Section
    # Again, skip first point as it's a duplicate of last point in Part D
    inner_rail_points.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                            NUM_STEPS_PER_FLIGHT, -1, handrail_x_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_rail_points, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # --- Generate Skirtings ---
    skirting_color = "Wood" 
    
    # First Flight Outer Skirting (profile at X=STAIR_WIDTH, extrude +X)
    outer_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, false) # is_inner = false means outer edge
    create_skirting(assembly_entities, outer_skirting_f1_profile, Geom::Vector3d.new(1, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting (profile at X=0, extrude -X)
    inner_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, true) # is_inner = true means inner edge
    create_skirting(assembly_entities, inner_skirting_f1_profile, Geom::Vector3d.new(-1, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing, extrude -Y)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -1, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing, extrude +Y)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, 1, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing, extrude +X)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(1, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Second Flight Outer Skirting (profile at X=flight2_x_offset + STAIR_WIDTH, extrude +X)
    outer_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, false)
    create_skirting(assembly_entities, outer_skirting_f2_profile, Geom::Vector3d.new(1, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting (profile at X=flight2_x_offset, extrude -X)
    inner_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, true)
    create_skirting(assembly_entities, inner_skirting_f2_profile, Geom::Vector3d.new(-1, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
=> #<Sketchup::View:0x000000001dac01d0>
module UStairsGeneratorEnhanced
  # --- Standard Dimensions (in millimeters) ---
  RISER_HEIGHT = 175.mm      # Vertical height of each step
  TREAD_DEPTH  = 260.mm      # Horizontal depth of each step
  STAIR_WIDTH  = 900.mm      # Width of each stair flight
  NUM_STEPS_PER_FLIGHT = 11

  # Dimensions for the U-turn landing and gap:
  LANDING_DEPTH_Y = STAIR_WIDTH # Depth of landing along Y-axis (direction of first flight)
  GAP_WIDTH_X = STAIR_WIDTH     # Space between the two parallel flights

  # --- Railing Dimensions ---
  HANDRAIL_HEIGHT_FROM_TREAD = 900.mm # Vertical distance from tread nosing to top of handrail
  HANDRAIL_WIDTH  = 50.mm             # Top surface width of the handrail
  HANDRAIL_DEPTH  = 70.mm             # Side surface depth of the handrail
  HANDRAIL_OFFSET_FROM_EDGE = 50.mm   # Horizontal offset from the stair's outer edge

  # --- Skirting Dimensions ---
  SKIRTING_THICKNESS = 20.mm
  SKIRTING_HEIGHT_ABOVE_NOSING = 100.mm # Minimum height of skirting above step nosing line

  # Helper method to create a solid group
  def self.create_solid_group(entities_collection, name="Unnamed Group")
    group = entities_collection.add_group
    group.name = name
    group
  end

  # Helper method to apply a color to a group
  def self.apply_color(group, color_name)
    model = Sketchup.active_model
    material = model.materials[color_name]
    unless material
      material = model.materials.add(color_name)
      # Define some basic colors if they don't exist
      case color_name
      when "Blue"  then material.color = Sketchup::Color.new(0, 150, 255) # Light Blue
      when "White" then material.color = Sketchup::Color.new(240, 240, 240) # Off-white
      when "Wood"  then material.color = Sketchup::Color.new(139, 69, 19) # Saddle Brown
      when "Grey"  then material.color = Sketchup::Color.new(150, 150, 150) # Medium Grey
      end
    end
    group.material = material
  end

  # Helper to create a single step block (tread + riser)
  def self.create_step_block(entities_collection, x_origin, y_front, y_back, z_top, width, height, name_prefix)
    group = create_solid_group(entities_collection, "#{name_prefix}_Step")
    face_entities = group.entities

    # Points for the top face of the tread
    pt1 = Geom::Point3d.new(x_origin, y_front, z_top)
    pt2 = Geom::Point3d.new(x_origin + width, y_front, z_top)
    pt3 = Geom::Point3d.new(x_origin + width, y_back, z_top)
    pt4 = Geom::Point3d.new(x_origin, y_back, z_top)

    face = face_entities.add_face([pt1, pt2, pt3, pt4])
    # Ensure face is valid before pushpull
    if face.valid?
      face.pushpull(-height)
    else
      puts "Warning: Invalid face created for step at #{pt1.to_s}"
      group.erase! # Delete the empty group if face creation failed
      return nil
    end
    group
  end

  # Helper to generate the path points for a handrail on one side of a flight
  # `direction_y` is +1 for first flight, -1 for second flight
  # `handrail_x_pos_offset` is the X-coordinate for the centerline of the handrail
  # Path points will define the CENTER of the handrail's cross-section.
  def self.generate_handrail_path_points(flight_x_offset, flight_y_base, flight_z_base,
                                         num_steps, direction_y, handrail_x_pos_offset)
    path_points = []
    
    # Start point on the ground plane, at the front of the first riser.
    # Z for handrail center at this level: flight_z_base (ground) + HANDRAIL_HEIGHT_FROM_TREAD (to top) - (HANDRAIL_DEPTH / 2) (to center)
    path_points << Geom::Point3d.new(handrail_x_pos_offset, flight_y_base,
                                     flight_z_base + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2))

    # Points above the nosing of each subsequent step
    (0...num_steps).each do |i|
      # Y-coordinate at the nosing of step (i+1)
      step_nosing_y = flight_y_base + ((i + 1) * TREAD_DEPTH * direction_y)
      # Z-coordinate at the nosing of step (i+1)
      step_nosing_z = flight_z_base + (i + 1) * RISER_HEIGHT
      
      # Handrail center Z-coordinate above this nosing
      handrail_center_z = step_nosing_z + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)
      
      path_points << Geom::Point3d.new(handrail_x_pos_offset, step_nosing_y, handrail_center_z)
    end
    path_points
  end

  # Helper to create a handrail using FollowMe
  def self.create_handrail(entities_collection, path_points, name)
    handrail_group = create_solid_group(entities_collection, name)
    group_entities = handrail_group.entities

    # 1. Create the path edges
    path_edges = group_entities.add_curve(path_points)
    unless path_edges && path_edges.length > 0 # A path needs at least one edge (two points)
      puts "Error: Invalid path for handrail #{name}. Not enough points: #{path_points.length} points."
      handrail_group.erase!
      return nil
    end

    # 2. Define the profile face's vertices directly in their correct, transformed positions.
    # The path_points define the center line of the handrail.
    # The profile face needs to be perpendicular to the first segment of the path.

    # Get the vector of the first segment of the path.
    v_path = (path_points[1] - path_points[0]).normalize
    
    # Create a transformation to align the profile at the start of the path.
    # v_path will be the local Y-axis (extrusion direction).
    # We need local X and Z axes perpendicular to v_path.
    # `v_path.axes` returns an array: [v_path, perpendicular_x, perpendicular_z] (arbitrary order for latter two).
    tr_profile_alignment = Geom::Transformation.axes(path_points.first, v_path.axes[1], v_path, v_path.axes[2])

    # Define the profile points relative to its own local origin (0,0,0) and axes.
    # The profile will be centered on path_points.first, and lie in the local XZ plane.
    local_pts = [
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-left
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0, -HANDRAIL_DEPTH / 2), # Bottom-right
      Geom::Point3d.new( HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2), # Top-right
      Geom::Point3d.new(-HANDRAIL_WIDTH / 2, 0,  HANDRAIL_DEPTH / 2)  # Top-left
    ]
    
    # Transform these local points to their absolute positions in the model space.
    absolute_pts = local_pts.map { |pt| pt.transform(tr_profile_alignment) }

    # Create the profile face in the group's entities
    profile_face = group_entities.add_face(absolute_pts)

    if profile_face.valid?
      # Ensure the face normal points *away* from the path's direction for FollowMe to work reliably.
      # If `profile_face.normal.dot(v_path)` is positive, the face is pointing along the path, so reverse it.
      if profile_face.normal.dot(v_path) > 0.001 # Use a small tolerance for comparison
        profile_face.reverse!
      end
      
      # Now use followme
      profile_face.followme(path_edges)
      return handrail_group
    else
      puts "Warning: FollowMe failed for handrail #{name}. Profile face creation failed or is invalid."
      handrail_group.erase!
      return nil
    end
  end
  
  # Helper to generate profile points for a stepped skirting face.
  # This returns a closed loop of points representing the side profile of the skirting.
  def self.generate_skirting_profile_points(flight_start_x, flight_start_y, flight_start_z,
                                              num_steps, direction_y, is_inner)
    profile_points = []
    x_pos = is_inner ? flight_start_x : flight_start_x + STAIR_WIDTH
    
    # 1. Start at the bottom-front corner (ground level for this flight segment)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z)

    # 2. Go up vertically to the top-front corner (skirting height at ground level)
    profile_points << Geom::Point3d.new(x_pos, flight_start_y, flight_start_z + SKIRTING_HEIGHT_ABOVE_NOSING)

    # 3. Trace the top stepped edge of the skirting (above the nosings)
    (0...num_steps).each do |i|
      y_tread_nosing = flight_start_y + (i + 1) * TREAD_DEPTH * direction_y
      z_tread_nosing = flight_start_z + (i + 1) * RISER_HEIGHT
      profile_points << Geom::Point3d.new(x_pos, y_tread_nosing, z_tread_nosing + SKIRTING_HEIGHT_ABOVE_NOSING)
    end
    
    # 4. Now trace the bottom stepped edge, going from the end of the flight back to the start.
    # Start from the bottom-back of the last riser (where it meets the landing/next segment)
    # The last riser's base point will be at Z = (NUM_STEPS_PER_FLIGHT) * RISER_HEIGHT
    # And Y = (NUM_STEPS_PER_FLIGHT) * TREAD_DEPTH * direction_y

    # First point on the way back down (bottom of the last riser)
    y_last_riser_base = flight_start_y + num_steps * TREAD_DEPTH * direction_y
    z_last_riser_base = flight_start_z + num_steps * RISER_HEIGHT
    profile_points << Geom::Point3d.new(x_pos, y_last_riser_base, z_last_riser_base)
    
    (num_steps - 1).downto(0) do |i|
      # This is the point at the base of riser (i+1) from the top (or riser `i` from the ground, where `i` is current step index)
      y_riser_base = flight_start_y + (i * TREAD_DEPTH * direction_y)
      z_riser_base = flight_start_z + (i * RISER_HEIGHT)
      profile_points << Geom::Point3d.new(x_pos, y_riser_base, z_riser_base)
    end
    
    # The last point added by the loop for i=0 is (x_pos, flight_start_y, flight_start_z) which is our first point.
    # To ensure a clean closed loop for `add_face` (no duplicate start/end point), remove the last point if it matches the first.
    if profile_points.last == profile_points.first
      profile_points.pop
    end
    
    return profile_points
  end

  # Helper to create a skirting by push-pulling a profile face
  def self.create_skirting(entities_collection, profile_points, extrusion_dir_unit_vector, name)
    skirting_group = create_solid_group(entities_collection, name)
    group_entities = skirting_group.entities

    face = group_entities.add_face(profile_points)

    if face.valid?
      # Determine the extrusion distance based on face normal relative to desired direction.
      # `extrusion_dir_unit_vector` defines the desired outward direction.
      # If face normal is generally aligned with `extrusion_dir_unit_vector`, pushpull by `SKIRTING_THICKNESS`.
      # Otherwise, pushpull by `-SKIRTING_THICKNESS`.
      if face.normal.dot(extrusion_dir_unit_vector).abs < 0.001
         puts "Warning: Skirting face normal is nearly perpendicular to extrusion vector for #{name}. Check points."
         skirting_group.erase!
         return nil
      elsif face.normal.dot(extrusion_dir_unit_vector) > 0 # Face normal points in the desired direction
        face.pushpull(SKIRTING_THICKNESS)
      else # Face normal points opposite to the desired direction
        face.pushpull(-SKIRTING_THICKNESS)
      end
    else
      puts "Warning: Invalid face created for skirting #{name} at #{profile_points.first.to_s}"
      skirting_group.erase!
      return nil
    end
    skirting_group
  end

  def self.generate_stairs
    model = Sketchup.active_model
    entities = model.active_entities

    model.start_operation("Generate U-Shape Stairs Enhanced", true)

    # --- Main Group for the entire staircase ---
    u_stairs_assembly = create_solid_group(entities, "U_Stairs_Assembly")
    assembly_entities = u_stairs_assembly.entities

    # --- 1. First Flight ---
    first_flight_group = create_solid_group(assembly_entities, "First_Flight")
    apply_color(first_flight_group, "White") # Matching the image: First flight is white
    
    # Coordinates for the first flight
    flight1_start_x = 0
    flight1_start_y = 0
    flight1_start_z = 0 # Base Z for the flight's ground level

    (0...NUM_STEPS_PER_FLIGHT).each do |i|
      current_tread_z = (i + 1) * RISER_HEIGHT
      current_tread_y_front = i * TREAD_DEPTH
      current_tread_y_back  = (i + 1) * TREAD_DEPTH
      
      create_step_block(first_flight_group.entities, flight1_start_x, current_tread_y_front, 
                        current_tread_y_back, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "First_Flight_")
    end

    # --- 2. Landing ---
    landing_group = create_solid_group(assembly_entities, "Landing")
    apply_color(landing_group, "Grey")

    landing_z_level = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT
    landing_y_start = NUM_STEPS_PER_FLIGHT * TREAD_DEPTH
    landing_y_end = landing_y_start + LANDING_DEPTH_Y
    landing_x_start = 0
    landing_x_end = STAIR_WIDTH + GAP_WIDTH_X + STAIR_WIDTH # Total width of the U-shape

    # Define the points for the top face of the landing.
    pt1_land = Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level)
    pt2_land = Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level)
    pt3_land = Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level)
    pt4_land = Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level)

    landing_face = landing_group.entities.add_face([pt1_land, pt2_land, pt3_land, pt4_land])
    landing_face.pushpull(-RISER_HEIGHT) if landing_face.valid?

    # --- 3. Second Flight ---
    # This flight starts at the landing's Z-level, is shifted in X, and recedes along the Y-axis.
    second_flight_group = create_solid_group(assembly_entities, "Second_Flight")
    apply_color(second_flight_group, "Blue") # Matching the image: Second flight is blue

    flight2_x_offset = STAIR_WIDTH + GAP_WIDTH_X
    # The second flight starts precisely from the far edge of the landing, stepping backwards.
    flight2_start_y = landing_y_end
    flight2_start_z = landing_z_level - RISER_HEIGHT # Base Z for the flight's ground equivalent (bottom of landing)

    (0...NUM_STEPS_PER_FLIGHT).each do |j|
      current_tread_z = landing_z_level + (j + 1) * RISER_HEIGHT
      
      # Define the Y-coordinates for the tread, receding from flight2_start_y.
      tread_y_front = flight2_start_y - j * TREAD_DEPTH
      tread_y_back = flight2_start_y - (j + 1) * TREAD_DEPTH

      create_step_block(second_flight_group.entities, flight2_x_offset, tread_y_back,
                        tread_y_front, current_tread_z, STAIR_WIDTH, RISER_HEIGHT, "Second_Flight_")
    end

    # --- Generate Handrails ---
    # The Z-level for handrails over the landing is constant.
    landing_handrail_z = (NUM_STEPS_PER_FLIGHT + 1) * RISER_HEIGHT + HANDRAIL_HEIGHT_FROM_TREAD - (HANDRAIL_DEPTH / 2)

    # X-offsets for the center of the handrails
    handrail_x_outer_f1 = STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_outer_f2 = flight2_x_offset + STAIR_WIDTH - HANDRAIL_OFFSET_FROM_EDGE - HANDRAIL_WIDTH / 2
    handrail_x_inner_f1 = HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2 
    handrail_x_inner_f2 = flight2_x_offset + HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2

    # --- Outer Handrail Path ---
    outer_rail_points = []
    
    # Part A: First Flight Section (from ground to landing level)
    outer_rail_points.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                            NUM_STEPS_PER_FLIGHT, 1, handrail_x_outer_f1))
    
    # Part B: Outer Landing Horizontal Segment (across X, at Y=landing_y_start)
    # The last point from Part A is `(handrail_x_outer_f1, landing_y_start, landing_handrail_z)`
    outer_rail_points << Geom::Point3d.new(handrail_x_outer_f2, outer_rail_points.last.y, landing_handrail_z)
    
    # Part C: Outer Landing Turn Segment (along Y) - connecting to start of second flight.
    # From `(handrail_x_outer_f2, landing_y_start, landing_handrail_z)` to `(handrail_x_outer_f2, landing_y_end, landing_handrail_z)`
    outer_rail_points << Geom::Point3d.new(handrail_x_outer_f2, flight2_start_y, landing_handrail_z) # flight2_start_y is landing_y_end
    
    # Part D: Second Flight Section (from landing level down to ground)
    # The first point generated by `generate_handrail_path_points` for F2 is `(handrail_x_outer_f2, flight2_start_y, landing_handrail_z)`.
    # This is exactly the last point added in Part C, so we skip it to avoid duplication.
    outer_rail_points.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                            NUM_STEPS_PER_FLIGHT, -1, handrail_x_outer_f2)[1..-1])

    create_handrail(assembly_entities, outer_rail_points, "Outer_Handrail")

    # --- Inner Handrail Path ---
    inner_rail_points = []

    # Part A: First Flight Inner Section
    inner_rail_points.concat(generate_handrail_path_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                            NUM_STEPS_PER_FLIGHT, 1, handrail_x_inner_f1))
    
    # Part B: Inner Landing Turn (Y-segment)
    # From end of F1 rail `(handrail_x_inner_f1, inner_rail_points.last.y, landing_handrail_z)`
    # to the inner corner of the gap: `(handrail_x_inner_f1, landing_y_end - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2), landing_handrail_z)`
    # NOTE: Offset for the inner corner needs to be `(landing_depth_y - (offset_from_edge + half_width))` from the 'y_start' of the landing.
    inner_gap_y_pos = landing_y_end - (HANDRAIL_OFFSET_FROM_EDGE + HANDRAIL_WIDTH / 2)
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f1, inner_gap_y_pos, landing_handrail_z)

    # Part C: Inner Landing Horizontal Segment (across X - the gap itself)
    # Across the gap to align with F2 inner rail starting X
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f2, inner_gap_y_pos, landing_handrail_z)

    # Part D: Inner Landing Turn (Y-segment)
    # From the end of Part C to the starting Y of F2 inner rail (`flight2_start_y`)
    inner_rail_points << Geom::Point3d.new(handrail_x_inner_f2, flight2_start_y, landing_handrail_z)

    # Part E: Second Flight Inner Section
    # Again, skip first point as it's a duplicate of last point in Part D
    inner_rail_points.concat(generate_handrail_path_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                            NUM_STEPS_PER_FLIGHT, -1, handrail_x_inner_f2)[1..-1])

    create_handrail(assembly_entities, inner_rail_points, "Inner_Handrail")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Outer_Handrail" }, "Wood")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Inner_Handrail" }, "Wood")


    # --- Generate Skirtings ---
    skirting_color = "Wood" 
    
    # First Flight Outer Skirting (profile at X=STAIR_WIDTH, extrude +X)
    outer_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, false) # is_inner = false means outer edge
    create_skirting(assembly_entities, outer_skirting_f1_profile, Geom::Vector3d.new(1, 0, 0), "First_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Outer_Skirting" }, skirting_color)

    # First Flight Inner Skirting (profile at X=0, extrude -X)
    inner_skirting_f1_profile = generate_skirting_profile_points(flight1_start_x, flight1_start_y, flight1_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, 1, true) # is_inner = true means inner edge
    create_skirting(assembly_entities, inner_skirting_f1_profile, Geom::Vector3d.new(-1, 0, 0), "First_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "First_Flight_Inner_Skirting" }, skirting_color)

    # Landing Front Skirting (along Y=landing_y_start, across X-width of landing, extrude -Y)
    sk_land_front_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_front_pts, Geom::Vector3d.new(0, -1, 0), "Landing_Front_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Front_Skirting" }, skirting_color)

    # Landing Back Skirting (along Y=landing_y_end, across X-width of landing, extrude +Y)
    sk_land_back_pts = [
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_start, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_back_pts, Geom::Vector3d.new(0, 1, 0), "Landing_Back_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Back_Skirting" }, skirting_color)

    # Landing Outer Skirting (along X=landing_x_end, across Y-depth of landing, extrude +X)
    sk_land_outer_pts = [
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level - RISER_HEIGHT),
      Geom::Point3d.new(landing_x_end, landing_y_start, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level),
      Geom::Point3d.new(landing_x_end, landing_y_end, landing_z_level - RISER_HEIGHT)
    ]
    create_skirting(assembly_entities, sk_land_outer_pts, Geom::Vector3d.new(1, 0, 0), "Landing_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Landing_Outer_Skirting" }, skirting_color)
    
    # Second Flight Outer Skirting (profile at X=flight2_x_offset + STAIR_WIDTH, extrude +X)
    outer_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, false)
    create_skirting(assembly_entities, outer_skirting_f2_profile, Geom::Vector3d.new(1, 0, 0), "Second_Flight_Outer_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Outer_Skirting" }, skirting_color)

    # Second Flight Inner Skirting (profile at X=flight2_x_offset, extrude -X)
    inner_skirting_f2_profile = generate_skirting_profile_points(flight2_x_offset, flight2_start_y, flight2_start_z,
                                                                 NUM_STEPS_PER_FLIGHT, -1, true)
    create_skirting(assembly_entities, inner_skirting_f2_profile, Geom::Vector3d.new(-1, 0, 0), "Second_Flight_Inner_Skirting")
    apply_color(assembly_entities.find { |e| e.is_a?(Sketchup::Group) && e.name == "Second_Flight_Inner_Skirting" }, skirting_color)

    # Commit the undo operation.
    model.commit_operation
    
    # Clear current selection, select the newly created stairs group, and zoom to its extents.
    model.selection.clear
    model.selection.add(u_stairs_assembly)
    Sketchup.active_model.active_view.zoom_extents
  end
end

# Example usage:
# Call the method to generate the stairs.
UStairsGeneratorEnhanced.generate_stairs

(eval):3: warning: already initialized constant UStairsGeneratorEnhanced::RISER_HEIGHT
(eval):3: warning: previous definition of RISER_HEIGHT was here
(eval):4: warning: already initialized constant UStairsGeneratorEnhanced::TREAD_DEPTH
(eval):4: warning: previous definition of TREAD_DEPTH was here
(eval):5: warning: already initialized constant UStairsGeneratorEnhanced::STAIR_WIDTH
(eval):5: warning: previous definition of STAIR_WIDTH was here
(eval):6: warning: already initialized constant UStairsGeneratorEnhanced::NUM_STEPS_PER_FLIGHT
(eval):6: warning: previous definition of NUM_STEPS_PER_FLIGHT was here
(eval):9: warning: already initialized constant UStairsGeneratorEnhanced::LANDING_DEPTH_Y
(eval):9: warning: previous definition of LANDING_DEPTH_Y was here
(eval):10: warning: already initialized constant UStairsGeneratorEnhanced::GAP_WIDTH_X
(eval):10: warning: previous definition of GAP_WIDTH_X was here
(eval):13: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_HEIGHT_FROM_TREAD
(eval):13: warning: previous definition of HANDRAIL_HEIGHT_FROM_TREAD was here
(eval):14: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_WIDTH
(eval):14: warning: previous definition of HANDRAIL_WIDTH was here
(eval):15: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_DEPTH
(eval):15: warning: previous definition of HANDRAIL_DEPTH was here
(eval):16: warning: already initialized constant UStairsGeneratorEnhanced::HANDRAIL_OFFSET_FROM_EDGE
(eval):16: warning: previous definition of HANDRAIL_OFFSET_FROM_EDGE was here
(eval):19: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_THICKNESS
(eval):19: warning: previous definition of SKIRTING_THICKNESS was here
(eval):20: warning: already initialized constant UStairsGeneratorEnhanced::SKIRTING_HEIGHT_ABOVE_NOSING
(eval):20: warning: previous definition of SKIRTING_HEIGHT_ABOVE_NOSING was here
=> #<Sketchup::View:0x000000001dac01d0>
